# 依赖注入

MiCake 增强了 .NET 的依赖注入功能，提供了更便捷的服务注册方式和生命周期管理。

## 自动服务注册

### 接口标记注册

通过实现特定接口，服务可以自动注册到 DI 容器：

```csharp
// 瞬时服务（Transient）
public class MyTransientService : ITransientService
{
    // 自动注册为 Transient 生命周期
}

// 作用域服务（Scoped）
public class MyService : IScopedService
{
    // 自动注册为 Scoped 生命周期
}

// 单例服务（Singleton）
public class MyCacheService : ISingletonService
{
    // 自动注册为 Singleton 生命周期
}
```

### 服务生命周期

```csharp
// Transient - 每次请求都创建新实例
public class EmailSender : ITransientService
{
    public void Send(string to, string message)
    {
        // 每次调用时都是新实例
    }
}

// Scoped - 每个作用域内创建一个实例（Web 请求内共享）
public class OrderService : IScopedService
{
    private readonly IRepository<Order, int> _repository;
    
    public OrderService(IRepository<Order, int> repository)
    {
        _repository = repository;
    }
}

// Singleton - 整个应用生命周期内只有一个实例
public class ConfigurationService : ISingletonService
{
    private readonly Dictionary<string, string> _config = new();
    
    public string Get(string key) => _config.TryGetValue(key, out var value) ? value : null;
}
```

## 手动注册服务

在模块中手动注册服务：

```csharp
public class MyAppModule : MiCakeModule
{
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        // 注册接口和实现
        context.Services.AddScoped<IOrderService, OrderService>();
        context.Services.AddTransient<IEmailService, EmailService>();
        context.Services.AddSingleton<ICacheService, CacheService>();
        
        // 注册泛型服务
        context.Services.AddScoped(typeof(IRepository<,>), typeof(Repository<,>));
        
        // 注册工厂方法
        context.Services.AddScoped<INotificationService>(sp =>
        {
            var config = sp.GetRequiredService<IConfiguration>();
            return new NotificationService(config["NotificationApiKey"]);
        });
        
        base.ConfigureServices(context);
    }
}
```

## 服务解析

### 构造函数注入

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Customer, int> _customerRepository;
    private readonly IEmailService _emailService;
    private readonly ILogger<OrderService> _logger;
    
    public OrderService(
        IRepository<Order, int> orderRepository,
        IRepository<Customer, int> customerRepository,
        IEmailService emailService,
        ILogger<OrderService> logger)
    {
        _orderRepository = orderRepository;
        _customerRepository = customerRepository;
        _emailService = emailService;
        _logger = logger;
    }
}
```

### 手动解析

```csharp
public class MyService
{
    private readonly IServiceProvider _serviceProvider;
    
    public MyService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    public void DoWork()
    {
        // 解析必需的服务
        var orderService = _serviceProvider.GetRequiredService<IOrderService>();
        
        // 解析可选的服务
        var cacheService = _serviceProvider.GetService<ICacheService>();
        
        // 创建作用域并解析服务
        using var scope = _serviceProvider.CreateScope();
        var scopedService = scope.ServiceProvider.GetRequiredService<IScopedService>();
    }
}
```

## 最佳实践

### 1. 优先使用接口

```csharp
// ✅ 好的做法
public interface IOrderService
{
    Task<Order> CreateOrder(CreateOrderDto dto);
}

public class OrderService : IOrderService, IScopedService
{
    public async Task<Order> CreateOrder(CreateOrderDto dto) { }
}

// 依赖接口
public class OrderController
{
    private readonly IOrderService _orderService;
    
    public OrderController(IOrderService orderService) { }
}
```

### 2. 避免服务定位器模式

```csharp
// ❌ 避免
public class BadService
{
    private readonly IServiceProvider _serviceProvider;
    
    public void DoWork()
    {
        var service = _serviceProvider.GetService<IOtherService>();
    }
}

// ✅ 推荐
public class GoodService
{
    private readonly IOtherService _otherService;
    
    public GoodService(IOtherService otherService)
    {
        _otherService = otherService;
    }
}
```

### 3. 注意生命周期

```csharp
// ❌ 错误 - Singleton 依赖 Scoped
public class MySingletonService : ISingletonService
{
    private readonly IScopedService _scopedService;  // 错误！
}

// ✅ 正确
public class MySingletonService : ISingletonService
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public MySingletonService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }
    
    public void DoWork()
    {
        using var scope = _scopeFactory.CreateScope();
        var scopedService = scope.ServiceProvider.GetRequiredService<IScopedService>();
    }
}
```

## 小结

MiCake 依赖注入：

- 通过接口标记自动注册
- 支持三种生命周期：Transient、Scoped、Singleton
- 在模块中配置服务
- 构造函数注入是首选方式

下一步：
- 学习[模块使用](./模块使用.md)了解模块配置
- 查看[核心概念](./核心概念.md)理解依赖注入原理
