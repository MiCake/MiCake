# 软删除支持

MiCake 提供了软删除（Soft Delete）功能，允许您逻辑删除实体而不是物理删除，便于数据恢复和审计。

## 什么是软删除

**物理删除**：从数据库中永久删除记录
**软删除**：只标记记录为已删除，数据仍保留在数据库中

软删除的优势：
- 可以恢复已删除的数据
- 保留完整的数据历史
- 便于审计和合规性
- 避免级联删除问题

## 实现软删除

### ISoftDelete 接口

```csharp
using MiCake.Audit.SoftDeletion;

public class Product : AggregateRoot<int>, ISoftDelete
{
    public string Name { get; private set; }
    public decimal Price { get; private set; }
    
    // 软删除字段
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
}
```

### 带审计的软删除

```csharp
public class Order : AggregateRoot<int>, ISoftDelete, IHasCreationTime
{
    public int CustomerId { get; private set; }
    public OrderStatus Status { get; private set; }
    
    // 审计字段
    public DateTime CreatedTime { get; set; }
    
    // 软删除字段
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
}
```

## 使用软删除

### 删除实体

```csharp
public async Task DeleteProduct(int productId)
{
    var product = await _productRepository.FindAsync(productId);
    if (product == null)
        throw new DomainException("Product not found");
    
    // 删除（实际是软删除）
    await _productRepository.DeleteAsync(product);
    await _productRepository.SaveChangesAsync();
    
    // 此时：
    // - IsDeleted 设置为 true
    // - DeletedTime 设置为当前时间
    // - 数据仍保留在数据库中
}
```

### 查询时自动过滤

软删除的数据在查询时会自动过滤：

```csharp
// 查询产品列表
var products = await _productRepository.Query()
    .Where(p => p.Price > 100)
    .ToListAsync();

// 自动添加 .Where(p => !p.IsDeleted) 过滤器
// 只返回未删除的产品
```

### 查询已删除的数据

如果需要查询已删除的数据：

```csharp
// 使用 EF Core 直接查询
var deletedProducts = await _dbContext.Products
    .IgnoreQueryFilters()  // 忽略软删除过滤器
    .Where(p => p.IsDeleted)
    .ToListAsync();
```

## 恢复已删除的数据

### 实现恢复方法

```csharp
public class Product : AggregateRoot<int>, ISoftDelete
{
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
    
    public void Restore()
    {
        if (!IsDeleted)
            throw new DomainException("Product is not deleted");
        
        IsDeleted = false;
        DeletedTime = null;
    }
}

// 使用恢复
public async Task RestoreProduct(int productId)
{
    var product = await _dbContext.Products
        .IgnoreQueryFilters()
        .FirstOrDefaultAsync(p => p.Id == productId);
    
    if (product == null)
        throw new DomainException("Product not found");
    
    product.Restore();
    await _productRepository.UpdateAsync(product);
    await _productRepository.SaveChangesAsync();
}
```

## 配置软删除

### DbContext 配置

```csharp
public class MyDbContext : MiCakeDbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // 必须调用基类方法以应用软删除配置
        base.OnModelCreating(modelBuilder);
        
        // MiCake 会自动为实现 ISoftDelete 的实体配置全局查询过滤器
        // 等同于：
        // modelBuilder.Entity<Product>()
        //     .HasQueryFilter(p => !p.IsDeleted);
    }
}
```

## 软删除与关联实体

### 级联软删除

```csharp
public class Order : AggregateRoot<int>, ISoftDelete
{
    private List<OrderItem> _items = new();
    
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
    
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    
    public void Delete()
    {
        // 软删除订单
        IsDeleted = true;
        DeletedTime = DateTime.UtcNow;
        
        // 同时软删除所有订单项
        foreach (var item in _items.OfType<ISoftDelete>())
        {
            item.IsDeleted = true;
            item.DeletedTime = DateTime.UtcNow;
        }
    }
}

public class OrderItem : Entity<int>, ISoftDelete
{
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
}
```

## 物理删除

如果需要真正删除数据：

```csharp
public async Task PermanentlyDeleteProduct(int productId)
{
    var product = await _dbContext.Products
        .IgnoreQueryFilters()
        .FirstOrDefaultAsync(p => p.Id == productId);
    
    if (product != null)
    {
        // 物理删除
        _dbContext.Products.Remove(product);
        await _dbContext.SaveChangesAsync();
    }
}
```

## 最佳实践

### 1. 敏感数据使用软删除

```csharp
// ✅ 用户数据使用软删除
public class User : AggregateRoot<int>, ISoftDelete
{
    public string Username { get; private set; }
    public string Email { get; private set; }
    
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
}

// 日志数据可以物理删除
public class SystemLog : Entity<long>
{
    // 不实现 ISoftDelete
}
```

### 2. 定期清理软删除的数据

```csharp
public class DataCleanupService
{
    private readonly MyDbContext _dbContext;
    
    public async Task CleanupOldDeletedRecords()
    {
        var cutoffDate = DateTime.UtcNow.AddYears(-1);
        
        var oldDeletedProducts = await _dbContext.Products
            .IgnoreQueryFilters()
            .Where(p => p.IsDeleted && p.DeletedTime < cutoffDate)
            .ToListAsync();
        
        _dbContext.Products.RemoveRange(oldDeletedProducts);
        await _dbContext.SaveChangesAsync();
    }
}
```

### 3. 唯一约束处理

```csharp
// 对于有唯一约束的字段，需要特殊处理
public class User : AggregateRoot<int>, ISoftDelete
{
    public string Username { get; private set; }
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
}

// EF Core 配置
modelBuilder.Entity<User>()
    .HasIndex(u => u.Username)
    .IsUnique()
    .HasFilter("IsDeleted = 0");  // 只对未删除的记录应用唯一约束
```

## 软删除审计

结合审计功能记录删除信息：

```csharp
public class Product : AggregateRoot<int>, ISoftDelete, IHasAudit
{
    // 创建信息
    public DateTime CreatedTime { get; set; }
    public int? CreatedBy { get; set; }
    
    // 修改信息
    public DateTime? ModifiedTime { get; set; }
    public int? ModifiedBy { get; set; }
    
    // 软删除信息
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
    public int? DeletedBy { get; set; }  // 谁删除的
}
```

## 小结

MiCake 软删除支持：

- 实现 `ISoftDelete` 接口
- 自动标记为已删除
- 查询时自动过滤
- 可以恢复已删除数据
- 保留完整数据历史

下一步：
- 学习[自动审计](./自动审计.md)了解审计功能
- 查看[仓储](./仓储.md)了解数据访问
