# 快速开始

本指南将帮助您在 ASP.NET Core 项目中快速集成 MiCake 框架，并创建一个简单的 DDD 应用。

## 前置要求

在开始之前，请确保您的开发环境满足以下要求：

- **.NET Core 5.0** 或更高版本
- **Visual Studio 2019** 或更高版本（或 VS Code / Rider）
- 基本的 **C#** 和 **ASP.NET Core** 知识
- 了解 **Entity Framework Core** 基础（可选）

## 第一步：安装 NuGet 包

在您的 ASP.NET Core 项目中，通过 NuGet 安装 MiCake 启动包。

### 使用 Package Manager Console

```powershell
Install-Package MiCake.AspNetCore.Start
```

### 使用 .NET CLI

```bash
dotnet add package MiCake.AspNetCore.Start
```

`MiCake.AspNetCore.Start` 包会自动引入所有必需的依赖项，包括：
- MiCake.Core
- MiCake（DDD 组件）
- MiCake.AspNetCore
- MiCake.EntityFrameworkCore

## 第二步：创建入口模块

在项目根目录创建一个继承自 `MiCakeModule` 的入口模块类。这个类告诉 MiCake 从哪个程序集启动。

```csharp
using MiCake.AspNetCore.Modules;
using MiCake.Core.Modularity;
using Microsoft.Extensions.DependencyInjection;

// 声明依赖 MiCake 的 ASP.NET Core 模块
[RelyOn(typeof(MiCakeAspNetCoreModule))]
public class MyAppModule : MiCakeModule
{
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        // 自动注册当前程序集中的仓储
        // 这会扫描程序集中的所有聚合根并自动创建对应的仓储
        context.AutoRegisterRepositories(typeof(MyAppModule).Assembly);

        base.ConfigureServices(context);
    }
}
```

**关键点说明：**

- `[RelyOn]` 特性声明模块依赖关系，确保所需模块先于当前模块初始化
- `ConfigureServices` 方法用于配置服务注册
- `AutoRegisterRepositories` 自动为聚合根创建仓储实例
- 入口模块通常放在 Web 项目或应用层

## 第三步：创建 DbContext

创建一个继承自 `MiCakeDbContext` 的数据库上下文类：

```csharp
using MiCake.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;

public class MyDbContext : MiCakeDbContext
{
    public MyDbContext(DbContextOptions<MyDbContext> options) : base(options)
    {
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        // 可以在此添加额外的配置
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // 非常重要：必须调用基类方法
        // 这会应用 MiCake 的实体配置（如审计字段、软删除等）
        base.OnModelCreating(modelBuilder);

        // 在此添加你的实体配置
        // modelBuilder.Entity<MyEntity>()...
    }
}
```

**重要提示：**

⚠️ 不要删除 `base.OnModelCreating(modelBuilder)` 这行代码！它负责配置 MiCake 的核心功能，如：
- 自动审计字段的映射
- 软删除过滤器
- 领域事件的处理

## 第四步：配置 Startup

在 `Startup.cs`（或 `Program.cs` for .NET 6+）中配置 MiCake：

### 对于 .NET 5 / ASP.NET Core 3.x：

```csharp
using MiCake.Core;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public IConfiguration Configuration { get; }

    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();

        // 配置 Entity Framework Core
        services.AddDbContext<MyDbContext>(options =>
        {
            options.UseSqlServer(
                Configuration.GetConnectionString("DefaultConnection")
            );
        });

        // 注册并配置 MiCake
        services.AddMiCakeWithDefault<MyAppModule, MyDbContext>(options =>
        {
            // 应用配置
            options.AppConfig = app =>
            {
                // 指定领域层程序集，用于自动发现实体
                app.DomainLayerAssemblies = new[] { typeof(MyAppModule).Assembly };
            };

            // ASP.NET Core 配置
            options.AspNetConfig = asp =>
            {
                // 启用统一返回格式包装
                asp.UseDataWrapper = true;
                asp.DataWrapperOptions.SuccessCode = "200";
                asp.DataWrapperOptions.SuccessMessage = "Success";
            };

            // 审计配置
            options.AuditConfig = audit =>
            {
                // 启用自动审计
                audit.Enable = true;
            };
        }).Build();  // 不要忘记调用 Build()
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseRouting();
        app.UseAuthorization();

        // 启动 MiCake - 必须在 UseEndpoints 之前调用
        app.StartMiCake();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
```

### 对于 .NET 6+ 的 Minimal API：

```csharp
using MiCake.Core;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// 添加服务
builder.Services.AddControllers();

// 配置 DbContext
builder.Services.AddDbContext<MyDbContext>(options =>
{
    options.UseSqlServer(
        builder.Configuration.GetConnectionString("DefaultConnection")
    );
});

// 配置 MiCake
builder.Services.AddMiCakeWithDefault<MyAppModule, MyDbContext>(options =>
{
    options.AppConfig = app =>
    {
        app.DomainLayerAssemblies = new[] { typeof(MyAppModule).Assembly };
    };
    options.AspNetConfig = asp =>
    {
        asp.UseDataWrapper = true;
    };
}).Build();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}

app.UseRouting();
app.UseAuthorization();

// 启动 MiCake
app.StartMiCake();

app.MapControllers();

app.Run();
```

**配置说明：**

- `AddMiCakeWithDefault<TModule, TDbContext>`：一站式配置方法
- `AppConfig`：配置应用级选项，如领域层程序集
- `AspNetConfig`：配置 ASP.NET Core 功能，如统一返回格式
- `AuditConfig`：配置审计功能
- `Build()`：构建 MiCake 模块系统
- `StartMiCake()`：启动 MiCake，初始化所有模块

## 第五步：创建领域对象

现在可以创建你的第一个聚合根和实体了。

### 创建聚合根

```csharp
using MiCake.DDD.Domain;

// 聚合根：书籍
public class Book : AggregateRoot<int>
{
    public string Title { get; private set; }
    public string Author { get; private set; }
    public decimal Price { get; private set; }
    public bool IsPublished { get; private set; }

    // EF Core 需要无参构造函数
    private Book() { }

    // 工厂方法：创建新书籍
    public static Book Create(string title, string author, decimal price)
    {
        var book = new Book
        {
            Title = title,
            Author = author,
            Price = price,
            IsPublished = false
        };

        // 发布领域事件
        book.RaiseDomainEvent(new BookCreatedEvent(book.Id, title));

        return book;
    }

    // 业务方法：出版书籍
    public void Publish()
    {
        if (IsPublished)
            throw new DomainException("Book is already published");

        IsPublished = true;
        RaiseDomainEvent(new BookPublishedEvent(Id, Title));
    }

    // 业务方法：更新价格
    public void UpdatePrice(decimal newPrice)
    {
        if (newPrice < 0)
            throw new DomainException("Price cannot be negative");

        Price = newPrice;
    }
}
```

### 创建领域事件

```csharp
using MiCake.DDD.Domain;

// 书籍创建事件
public class BookCreatedEvent : IDomainEvent
{
    public int BookId { get; }
    public string Title { get; }

    public BookCreatedEvent(int bookId, string title)
    {
        BookId = bookId;
        Title = title;
    }
}

// 书籍出版事件
public class BookPublishedEvent : IDomainEvent
{
    public int BookId { get; }
    public string Title { get; }

    public BookPublishedEvent(int bookId, string title)
    {
        BookId = bookId;
        Title = title;
    }
}
```

### 创建领域事件处理器

```csharp
using MiCake.DDD.Domain;
using System.Threading;
using System.Threading.Tasks;

public class BookCreatedEventHandler : IDomainEventHandler<BookCreatedEvent>
{
    public Task HandleAysnc(BookCreatedEvent domainEvent, CancellationToken cancellationToken = default)
    {
        // 处理书籍创建事件，例如发送通知、记录日志等
        Console.WriteLine($"New book created: {domainEvent.Title}");
        return Task.CompletedTask;
    }
}
```

## 第六步：使用仓储

在 Controller 或 Application Service 中使用仓储：

```csharp
using MiCake.DDD.Domain;
using Microsoft.AspNetCore.Mvc;
using System.Threading.Tasks;

[ApiController]
[Route("api/[controller]")]
public class BooksController : ControllerBase
{
    private readonly IRepository<Book, int> _bookRepository;

    public BooksController(IRepository<Book, int> bookRepository)
    {
        _bookRepository = bookRepository;
    }

    // 创建书籍
    [HttpPost]
    public async Task<IActionResult> CreateBook(CreateBookDto dto)
    {
        // 使用工厂方法创建聚合根
        var book = Book.Create(dto.Title, dto.Author, dto.Price);

        // 添加到仓储
        await _bookRepository.AddAsync(book);

        // 保存更改 - 此时会自动派发领域事件
        await _bookRepository.SaveChangesAsync();

        return Ok(book);
    }

    // 获取书籍
    [HttpGet("{id}")]
    public async Task<IActionResult> GetBook(int id)
    {
        var book = await _bookRepository.FindAsync(id);
        if (book == null)
            return NotFound();

        return Ok(book);
    }

    // 出版书籍
    [HttpPost("{id}/publish")]
    public async Task<IActionResult> PublishBook(int id)
    {
        var book = await _bookRepository.FindAsync(id);
        if (book == null)
            return NotFound();

        // 调用业务方法
        book.Publish();

        // 更新聚合根
        await _bookRepository.UpdateAsync(book);
        await _bookRepository.SaveChangesAsync();

        return Ok();
    }
}

// DTO 定义
public class CreateBookDto
{
    public string Title { get; set; }
    public string Author { get; set; }
    public decimal Price { get; set; }
}
```

## 第七步：运行和测试

1. **应用数据库迁移**：

```bash
# 创建迁移
dotnet ef migrations add InitialCreate

# 更新数据库
dotnet ef database update
```

2. **运行应用**：

```bash
dotnet run
```

3. **测试 API**：

```bash
# 创建书籍
curl -X POST https://localhost:5001/api/books \
  -H "Content-Type: application/json" \
  -d '{"title":"DDD实战","author":"张三","price":89.00}'

# 获取书籍
curl https://localhost:5001/api/books/1

# 出版书籍
curl -X POST https://localhost:5001/api/books/1/publish
```

## 统一返回格式示例

当启用 `UseDataWrapper = true` 后，API 返回格式会被自动包装：

```json
{
  "code": "200",
  "message": "Success",
  "data": {
    "id": 1,
    "title": "DDD实战",
    "author": "张三",
    "price": 89.00,
    "isPublished": false
  }
}
```

## 常见问题

### 1. 仓储无法注入

**问题**：运行时提示找不到 `IRepository<Book, int>` 的实现。

**解决**：
- 确保在模块的 `ConfigureServices` 中调用了 `AutoRegisterRepositories`
- 确保 `Book` 继承自 `AggregateRoot` 或 `AggregateRoot<TKey>`

### 2. 领域事件未触发

**问题**：领域事件处理器没有执行。

**解决**：
- 确保调用了 `await repository.SaveChangesAsync()`
- 领域事件会在 `SaveChangesAsync` 时自动派发
- 确保事件处理器实现了 `IDomainEventHandler<TEvent>`

### 3. 审计字段为空

**问题**：CreatedTime、ModifiedTime 等字段没有自动填充。

**解决**：
- 确保 DbContext 的 `OnModelCreating` 调用了 `base.OnModelCreating(modelBuilder)`
- 确保在 `AuditConfig` 中启用了审计功能

### 4. 忘记调用 Build()

**问题**：运行时出现模块未初始化的错误。

**解决**：
- 确保 `AddMiCakeWithDefault(...).Build()` 调用了 `Build()` 方法

## 下一步

恭喜！您已经成功搭建了一个基于 MiCake 的 DDD 应用。接下来可以：

- 学习 [核心概念](./核心概念.md) 深入理解 MiCake 的设计
- 阅读 [实体](./实体.md) 了解实体的详细用法
- 探索 [聚合根](./聚合根.md) 学习聚合的设计原则
- 查看 [领域事件](./领域事件.md) 掌握事件驱动开发
- 学习 [仓储](./仓储.md) 了解数据持久化的最佳实践

## 完整示例

查看 `samples/BaseMiCakeApplication` 目录，里面有一个完整的示例应用，展示了 MiCake 的各种功能。

## 获取帮助

如果遇到问题，可以：
- 查看 [GitHub Issues](https://github.com/MiCake/MiCake/issues)
- 阅读详细的功能文档
- 参考示例代码
