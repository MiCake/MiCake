# 异常处理

MiCake 提供了统一的异常处理机制，用于捕获和处理应用程序中的各种异常。

## 领域异常

### DomainException

用于表示业务规则违反：

```csharp
using MiCake.DDD.Domain;

public class Order : AggregateRoot<int>
{
    public void Submit()
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException("Only draft orders can be submitted");
            
        if (!Items.Any())
            throw new DomainException("Cannot submit empty order");
            
        Status = OrderStatus.Submitted;
    }
}
```

### 自定义领域异常

```csharp
public class InsufficientStockException : DomainException
{
    public int ProductId { get; }
    public int RequestedQuantity { get; }
    public int AvailableStock { get; }
    
    public InsufficientStockException(int productId, int requested, int available)
        : base($"Insufficient stock for product {productId}. Requested: {requested}, Available: {available}")
    {
        ProductId = productId;
        RequestedQuantity = requested;
        AvailableStock = available;
    }
}

// 使用
public class Product : AggregateRoot<int>
{
    public void DecreaseStock(int quantity)
    {
        if (Stock < quantity)
            throw new InsufficientStockException(Id, quantity, Stock);
            
        Stock -= quantity;
    }
}
```

## 全局异常处理

MiCake 提供全局异常处理，自动将异常转换为统一的响应格式：

```csharp
// 发生异常时
throw new DomainException("Order not found");

// 自动转换为 HTTP 响应
{
  "code": "500",
  "message": "Order not found",
  "data": null
}
```

## 异常处理器

### 自定义异常处理器

```csharp
public class CustomExceptionHandler : IMiCakeExceptionHandler
{
    public Task<bool> HandleAsync(Exception exception, ExceptionContext context)
    {
        if (exception is InsufficientStockException stockEx)
        {
            context.Result = new ObjectResult(new
            {
                code = "INSUFFICIENT_STOCK",
                message = stockEx.Message,
                productId = stockEx.ProductId,
                available = stockEx.AvailableStock
            })
            {
                StatusCode = 400
            };
            
            return Task.FromResult(true);  // 已处理
        }
        
        return Task.FromResult(false);  // 未处理，继续下一个处理器
    }
}
```

### 注册异常处理器

```csharp
public class MyAppModule : MiCakeModule
{
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        context.Services.Configure<MiCakeAspNetOptions>(options =>
        {
            options.ExceptionHandlers.Add(new CustomExceptionHandler());
        });
        
        base.ConfigureServices(context);
    }
}
```

## 最佳实践

### 1. 使用特定的异常类型

```csharp
// ✅ 好的做法
public class OrderNotFoundException : DomainException
{
    public OrderNotFoundException(int orderId)
        : base($"Order {orderId} not found") { }
}

// ❌ 避免泛化
throw new Exception("Something went wrong");
```

### 2. 异常信息应该有意义

```csharp
// ✅ 清晰的错误信息
throw new DomainException("Cannot cancel order: Order has already been shipped");

// ❌ 模糊的信息
throw new DomainException("Invalid operation");
```

### 3. 在适当的层级捕获异常

```csharp
// ✅ 在应用服务层处理
public class OrderApplicationService
{
    public async Task<Result<OrderDto>> CreateOrder(CreateOrderDto dto)
    {
        try
        {
            var order = Order.Create(dto.CustomerId);
            await _orderRepository.AddAsync(order);
            await _orderRepository.SaveChangesAsync();
            return Result.Success(MapToDto(order));
        }
        catch (DomainException ex)
        {
            return Result.Failure<OrderDto>(ex.Message);
        }
    }
}
```

## 小结

MiCake 异常处理：

- 使用 `DomainException` 表示业务规则违反
- 全局异常处理自动转换响应
- 支持自定义异常处理器
- 提供统一的错误响应格式
