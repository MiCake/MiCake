# 工具集

MiCake 提供了一系列实用工具类，帮助您更高效地开发应用程序。

## 缓存工具

### BoundedLruCache

线程安全的 LRU（Least Recently Used）缓存，具有容量限制：

```csharp
using MiCake.Util.Cache;

// 创建缓存，最大容量 1000 个条目
var cache = new BoundedLruCache<string, Product>(maxSize: 1000);

// 添加或获取缓存项
var product = cache.GetOrAdd("product-1", key =>
{
    // 如果缓存中不存在，执行工厂方法
    return LoadProductFromDatabase(key);
});

// 尝试获取缓存项
if (cache.TryGetValue("product-1", out var cachedProduct))
{
    return cachedProduct;
}

// 清除缓存
cache.Clear();

// 释放资源
cache.Dispose();
```

#### 高级配置

```csharp
// 使用分段提高并发性能
var cache = new BoundedLruCache<string, Product>(
    maxSize: 10000,
    segments: 4,  // 分为 4 个段
    useLockFreeApproximation: true  // 使用无锁近似算法
);

// 获取缓存统计
int count = cache.Count;
```

#### 使用场景

```csharp
public class ProductService
{
    private readonly BoundedLruCache<int, Product> _cache;
    private readonly IRepository<Product, int> _repository;
    
    public ProductService(IRepository<Product, int> repository)
    {
        _repository = repository;
        _cache = new BoundedLruCache<int, Product>(maxSize: 500);
    }
    
    public async Task<Product> GetProduct(int id)
    {
        return _cache.GetOrAdd(id, async productId =>
        {
            var product = await _repository.FindAsync(productId);
            if (product == null)
                throw new DomainException("Product not found");
            return product;
        });
    }
    
    public void InvalidateCache(int productId)
    {
        _cache.Remove(productId);
    }
}
```

## 转换器工具

### 类型转换

MiCake 提供了灵活的类型转换工具：

```csharp
using MiCake.Util.Convert;

// 基本类型转换
int intValue = Converter.To<int>("123");
DateTime dateValue = Converter.To<DateTime>("2024-01-01");

// 安全转换（失败返回默认值）
int result = Converter.ToOrDefault<int>("abc", defaultValue: 0);

// 自定义转换器
public class MoneyConverter : ITypeConverter<string, Money>
{
    public Money Convert(string source)
    {
        var parts = source.Split(' ');
        return new Money(decimal.Parse(parts[0]), parts[1]);
    }
}

// 注册自定义转换器
ConverterRegistry.Register(new MoneyConverter());

// 使用
Money money = Converter.To<Money>("99.99 USD");
```

## 查询工具

### 动态查询构建

```csharp
using MiCake.Util.Query;

// 构建动态查询
public async Task<List<Product>> SearchProducts(ProductSearchDto search)
{
    var query = _productRepository.Query();
    
    // 动态添加查询条件
    if (!string.IsNullOrEmpty(search.Name))
    {
        query = query.Where(p => p.Name.Contains(search.Name));
    }
    
    if (search.MinPrice.HasValue)
    {
        query = query.Where(p => p.Price >= search.MinPrice.Value);
    }
    
    if (search.MaxPrice.HasValue)
    {
        query = query.Where(p => p.Price <= search.MaxPrice.Value);
    }
    
    if (search.CategoryId.HasValue)
    {
        query = query.Where(p => p.CategoryId == search.CategoryId.Value);
    }
    
    // 动态排序
    query = search.SortBy switch
    {
        "name" => query.OrderBy(p => p.Name),
        "price" => query.OrderBy(p => p.Price),
        "date" => query.OrderByDescending(p => p.CreatedTime),
        _ => query.OrderBy(p => p.Id)
    };
    
    return await query.ToListAsync();
}
```

### 分页查询

```csharp
public async Task<PagedResult<Product>> GetProductsPaged(int pageIndex, int pageSize)
{
    var query = _productRepository.Query();
    
    var totalCount = await query.CountAsync();
    var items = await query
        .Skip((pageIndex - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();
    
    return new PagedResult<Product>
    {
        Items = items,
        TotalCount = totalCount,
        PageIndex = pageIndex,
        PageSize = pageSize
    };
}
```

## 弹性工具

### 熔断器（Circuit Breaker）

保护系统免受外部服务故障影响：

```csharp
using MiCake.Util.Resilience.CircuitBreaker;

// 创建熔断器
var circuitBreaker = new CircuitBreaker(
    failureThreshold: 5,  // 失败 5 次后打开熔断器
    timeout: TimeSpan.FromSeconds(60)  // 60 秒后尝试恢复
);

// 使用熔断器
public async Task<string> CallExternalService()
{
    return await circuitBreaker.ExecuteAsync(async () =>
    {
        // 调用外部服务
        var response = await _httpClient.GetStringAsync("https://api.example.com/data");
        return response;
    });
}
```

#### 熔断器状态

```
Closed（关闭）→ Open（打开）→ HalfOpen（半开）→ Closed
   ↑                ↓                ↓
正常运行        失败次数超限        尝试恢复
```

### 重试策略

```csharp
public async Task<Product> GetProductWithRetry(int id)
{
    int maxRetries = 3;
    int retryCount = 0;
    
    while (retryCount < maxRetries)
    {
        try
        {
            return await _repository.FindAsync(id);
        }
        catch (Exception ex)
        {
            retryCount++;
            if (retryCount >= maxRetries)
                throw;
            
            // 指数退避
            await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, retryCount)));
        }
    }
    
    throw new Exception("Max retries exceeded");
}
```

## 存储工具

### 内存存储

```csharp
using MiCake.Util.Store;

// 简单的键值存储
public class InMemoryStore<TKey, TValue>
{
    private readonly ConcurrentDictionary<TKey, TValue> _storage = new();
    
    public void Set(TKey key, TValue value)
    {
        _storage[key] = value;
    }
    
    public TValue Get(TKey key)
    {
        return _storage.TryGetValue(key, out var value) ? value : default;
    }
    
    public bool TryGet(TKey key, out TValue value)
    {
        return _storage.TryGetValue(key, out value);
    }
    
    public void Remove(TKey key)
    {
        _storage.TryRemove(key, out _);
    }
    
    public void Clear()
    {
        _storage.Clear();
    }
}
```

## 扩展方法

### 集合扩展

```csharp
using MiCake.Util.Extensions;

// 安全的 ForEach
items.SafeForEach(item => Console.WriteLine(item));

// 批处理
var batches = items.Batch(batchSize: 100);
foreach (var batch in batches)
{
    await ProcessBatchAsync(batch);
}

// 去重
var distinctItems = items.DistinctBy(x => x.Id);
```

### 字符串扩展

```csharp
// 判空
if (str.IsNullOrEmpty()) { }
if (str.IsNullOrWhiteSpace()) { }

// 截断
string truncated = longText.Truncate(maxLength: 100);

// 转换
string camelCase = "HelloWorld".ToCamelCase();  // "helloWorld"
string snakeCase = "HelloWorld".ToSnakeCase();  // "hello_world"
```

### 日期时间扩展

```csharp
// 日期范围
bool isInRange = date.IsBetween(startDate, endDate);

// 相对时间
string relative = date.ToRelativeTime();  // "2 hours ago"

// 时间戳
long timestamp = DateTime.UtcNow.ToUnixTimestamp();
DateTime date = timestamp.FromUnixTimestamp();
```

## 验证工具

### 参数验证

```csharp
using MiCake.Util;

public void CreateOrder(string customerName, decimal amount)
{
    // 验证参数
    CheckValue.NotNullOrEmpty(customerName, nameof(customerName));
    CheckValue.MustBePositive(amount, nameof(amount));
    
    // 业务逻辑
}

public class CheckValue
{
    public static void NotNull(object value, string paramName)
    {
        if (value == null)
            throw new ArgumentNullException(paramName);
    }
    
    public static void NotNullOrEmpty(string value, string paramName)
    {
        if (string.IsNullOrEmpty(value))
            throw new ArgumentException("Value cannot be null or empty", paramName);
    }
    
    public static void MustBePositive(decimal value, string paramName)
    {
        if (value <= 0)
            throw new ArgumentException("Value must be positive", paramName);
    }
}
```

## 表达式工具

### 动态表达式构建

```csharp
using MiCake.Util.Expressions;

// 构建动态过滤表达式
public Expression<Func<Product, bool>> BuildFilter(ProductFilter filter)
{
    Expression<Func<Product, bool>> predicate = p => true;
    
    if (!string.IsNullOrEmpty(filter.Name))
    {
        predicate = predicate.And(p => p.Name.Contains(filter.Name));
    }
    
    if (filter.MinPrice.HasValue)
    {
        predicate = predicate.And(p => p.Price >= filter.MinPrice.Value);
    }
    
    return predicate;
}
```

## 随机工具

### RandomHelper

```csharp
using MiCake.Util;

// 生成随机数
int randomInt = RandomHelper.Next(1, 100);

// 生成随机字符串
string randomCode = RandomHelper.GenerateRandomString(length: 6);

// 生成 GUID
string guid = RandomHelper.GenerateGuid();

// 从列表中随机选择
var item = RandomHelper.Choose(items);
```

## 最佳实践

### 1. 合理使用缓存

```csharp
// ✅ 缓存不经常变化的数据
var categories = cache.GetOrAdd("all-categories", LoadCategories);

// ❌ 避免缓存经常变化的数据
var orders = cache.GetOrAdd("user-orders", LoadOrders);  // 不推荐
```

### 2. 使用熔断器保护外部调用

```csharp
// ✅ 保护外部 API 调用
await circuitBreaker.ExecuteAsync(() => CallExternalApi());

// 提供降级方案
try
{
    return await circuitBreaker.ExecuteAsync(() => CallExternalApi());
}
catch (CircuitBreakerOpenException)
{
    // 熔断器打开，返回默认值或缓存数据
    return GetCachedData();
}
```

### 3. 工具类使用单例

```csharp
// ✅ 注册为单例
services.AddSingleton<BoundedLruCache<string, Product>>();

// 在服务中注入使用
public class ProductService
{
    private readonly BoundedLruCache<string, Product> _cache;
    
    public ProductService(BoundedLruCache<string, Product> cache)
    {
        _cache = cache;
    }
}
```

## 小结

MiCake 工具集提供：

- **缓存**：线程安全的 LRU 缓存
- **转换器**：灵活的类型转换
- **查询**：动态查询构建和分页
- **弹性**：熔断器和重试策略
- **存储**：内存键值存储
- **扩展方法**：常用功能扩展
- **验证**：参数验证工具
- **随机**：随机数生成

这些工具可以帮助您更高效地开发 MiCake 应用程序。
