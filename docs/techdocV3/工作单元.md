# 工作单元

工作单元（Unit of Work）是一种设计模式，用于维护受业务事务影响的对象列表，并协调这些对象的持久化工作。

## 什么是工作单元

工作单元的核心职责：

1. **跟踪变更**：跟踪业务操作期间所有对象的变更
2. **协调持久化**：将所有变更作为一个事务提交
3. **保证一致性**：确保数据的完整性和一致性
4. **管理事务**：控制事务的开始、提交和回滚

## MiCake 中的工作单元

在 MiCake 中，工作单元由以下组件协同实现：

### 1. DbContext 作为工作单元

EF Core 的 `DbContext` 本身就是一个工作单元：

```csharp
public class MyDbContext : MiCakeDbContext
{
    public MyDbContext(DbContextOptions<MyDbContext> options) : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        // 配置实体
    }
}
```

### 2. 仓储内部使用工作单元

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Customer, int> _customerRepository;

    public async Task CreateOrder(int customerId, List<OrderItemDto> items)
    {
        // 1. 所有操作在同一个工作单元中
        var customer = await _customerRepository.FindAsync(customerId);
        customer.IncreaseOrderCount();

        var order = Order.Create(customerId);
        foreach (var item in items)
        {
            order.AddItem(item.ProductId, item.Quantity, item.Price);
        }

        await _orderRepository.AddAsync(order);

        // 2. SaveChangesAsync 提交整个工作单元
        await _orderRepository.SaveChangesAsync();
        // 此时：
        // - Customer 和 Order 的变更一起提交
        // - 作为一个事务执行
        // - 要么全部成功，要么全部回滚
    }
}
```

## 工作单元的生命周期

```
1. 开始工作单元
   services.AddScoped<MyDbContext>()
      ↓
2. 跟踪对象变更
   customer.UpdateInfo()
   order.AddItem()
      ↓
3. 业务逻辑执行
   多个仓储操作
   多个聚合修改
      ↓
4. 提交工作单元
   await repository.SaveChangesAsync()
      ↓
5. 事务提交
   - 验证变更
   - 派发领域事件
   - 提交到数据库
      ↓
6. 清理资源
   DbContext Dispose
```

## 使用工作单元

### 基本用法

```csharp
public class OrderApplicationService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Product, int> _productRepository;

    public async Task CreateOrderAndUpdateStock(CreateOrderDto dto)
    {
        // 开始工作单元（自动开始）
        var order = Order.Create(dto.CustomerId);

        foreach (var item in dto.Items)
        {
            // 添加订单项
            order.AddItem(item.ProductId, item.Quantity, item.Price);

            // 更新库存
            var product = await _productRepository.FindAsync(item.ProductId);
            product.DecreaseStock(item.Quantity);
            await _productRepository.UpdateAsync(product);
        }

        await _orderRepository.AddAsync(order);

        // 提交工作单元 - 所有更改作为一个事务提交
        await _orderRepository.SaveChangesAsync();
    }
}
```

### 显式事务控制

对于需要更精确控制的场景：

```csharp
public class OrderService
{
    private readonly MyDbContext _dbContext;
    private readonly IRepository<Order, int> _orderRepository;

    public async Task ComplexOrderOperation(int orderId)
    {
        // 开始显式事务
        using var transaction = await _dbContext.Database.BeginTransactionAsync();

        try
        {
            var order = await _orderRepository.FindAsync(orderId);
            order.Process();

            await _orderRepository.UpdateAsync(order);
            await _orderRepository.SaveChangesAsync();

            // 调用外部服务
            await CallExternalPaymentService(order);

            // 提交事务
            await transaction.CommitAsync();
        }
        catch (Exception)
        {
            // 回滚事务
            await transaction.RollbackAsync();
            throw;
        }
    }
}
```

## 最佳实践

### 1. 保持工作单元的粒度适中

```csharp
// ✅ 好的做法 - 一个业务操作一个工作单元
public async Task ProcessOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    order.Process();
    
    await _orderRepository.UpdateAsync(order);
    await _orderRepository.SaveChangesAsync();  // 完成一个业务操作
}

// ❌ 避免 - 工作单元范围过大
public async Task ProcessAllOrders()
{
    var orders = await _orderRepository.Query().ToListAsync();
    
    foreach (var order in orders)  // 循环中包含太多操作
    {
        order.Process();
        await _orderRepository.UpdateAsync(order);
    }
    
    await _orderRepository.SaveChangesAsync();  // 一次性提交所有更改
}
```

### 2. 一个工作单元修改一个聚合

```csharp
// ✅ 推荐 - 一个事务一个聚合
public async Task SubmitOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    order.Submit();
    
    await _orderRepository.UpdateAsync(order);
    await _orderRepository.SaveChangesAsync();
}

// 如果需要修改其他聚合，使用领域事件
public class OrderSubmittedEventHandler : IDomainEventHandler<OrderSubmittedEvent>
{
    private readonly IRepository<Inventory, int> _inventoryRepository;
    
    public async Task HandleAysnc(OrderSubmittedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 在新的工作单元中处理库存
        var inventory = await _inventoryRepository.FindAsync(domainEvent.ProductId);
        inventory.DecreaseStock(domainEvent.Quantity);
        
        await _inventoryRepository.UpdateAsync(inventory);
        await _inventoryRepository.SaveChangesAsync(cancellationToken);
    }
}
```

### 3. 处理并发冲突

```csharp
public async Task UpdateProduct(int productId, UpdateProductDto dto)
{
    try
    {
        var product = await _productRepository.FindAsync(productId);
        product.Update(dto.Name, dto.Price);
        
        await _productRepository.UpdateAsync(product);
        await _productRepository.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException)
    {
        // 处理并发冲突
        throw new DomainException("Product has been modified by another user");
    }
}
```

## IUnitOfWork 接口

MiCake 提供了 `IUnitOfWork` 接口用于显式管理工作单元：

```csharp
public interface IUnitOfWork
{
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
    Task BeginTransactionAsync();
    Task CommitTransactionAsync();
    Task RollbackTransactionAsync();
}
```

## 工作单元与领域事件

工作单元在提交时会自动处理领域事件：

```
SaveChangesAsync() 执行流程：

1. 验证实体变更
2. 开始事务
3. 持久化数据到数据库
4. 收集所有领域事件
5. 按顺序派发事件
6. 提交事务
7. 清除已派发的事件
```

## 小结

工作单元模式在 MiCake 中：

- DbContext 作为工作单元实现
- 通过 SaveChangesAsync 提交变更
- 支持事务管理
- 自动派发领域事件
- 保证数据一致性

下一步：
- 学习[仓储](./仓储.md)了解数据访问
- 阅读[领域事件](./领域事件.md)理解事件处理
- 查看[聚合根](./聚合根.md)理解聚合边界
