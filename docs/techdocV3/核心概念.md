# 核心概念

本文介绍 MiCake 框架中的核心概念，帮助您更好地理解和使用框架。

## 模块系统

### 什么是模块

MiCake 采用模块化设计，应用程序由多个模块组成。每个模块都是一个独立的功能单元，可以：
- 配置自己的服务
- 管理自己的生命周期
- 声明对其他模块的依赖

### 模块生命周期

每个模块都有明确的生命周期钩子：

```csharp
public class MyModule : MiCakeModule
{
    // 1. 配置服务阶段
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        // 注册服务到 DI 容器
        context.Services.AddScoped<IMyService, MyService>();
    }

    // 2. 应用初始化阶段
    public override void OnApplicationInitialization(ModuleInitializationContext context)
    {
        // 应用启动时的初始化逻辑
        var logger = context.ServiceProvider.GetService<ILogger>();
        logger.LogInformation("Module initialized");
    }

    // 3. 应用关闭阶段
    public override void OnApplicationShutdown(ModuleShutdownContext context)
    {
        // 应用关闭时的清理逻辑
    }
}
```

### 模块依赖

使用 `[RelyOn]` 特性声明模块间的依赖关系：

```csharp
[RelyOn(typeof(MiCakeAspNetCoreModule))]
[RelyOn(typeof(MiCakeEntityFrameworkCoreModule))]
public class MyAppModule : MiCakeModule
{
    // 框架会确保依赖的模块先初始化
}
```

## 领域驱动设计（DDD）

### DDD 的核心思想

MiCake 实现了 DDD 战术模式的核心组件：

1. **实体（Entity）**：具有唯一标识的对象
2. **值对象（Value Object）**：通过属性值比较的不可变对象
3. **聚合根（Aggregate Root）**：聚合的根实体
4. **仓储（Repository）**：提供聚合根的持久化
5. **领域事件（Domain Event）**：捕获业务事件
6. **领域服务（Domain Service）**：封装领域逻辑

### 聚合边界

聚合是一组相关对象的集合，通过聚合根访问：

```
┌─────────────────────────────────┐
│  Aggregate (Order)              │
│  ┌──────────────────────────┐   │
│  │ Aggregate Root (Order)   │◄──┼─── 外部只能通过聚合根访问
│  │  - OrderId               │   │
│  │  - Customer              │   │
│  │  - Status                │   │
│  └──────────────────────────┘   │
│         │ manages               │
│         ▼                        │
│  ┌──────────────────────────┐   │
│  │ Entity (OrderItem)       │   │
│  │  - ProductId             │   │
│  │  - Quantity              │   │
│  │  - Price                 │   │
│  └──────────────────────────┘   │
└─────────────────────────────────┘
```

### 实体 vs 值对象

**实体特征：**
- 有唯一标识（Id）
- 可变的
- 通过 Id 比较相等性
- 有生命周期

```csharp
public class Order : AggregateRoot<int>
{
    public int Id { get; init; }  // 唯一标识
    public string OrderNumber { get; private set; }
    // ...
}
```

**值对象特征：**
- 无唯一标识
- 不可变的
- 通过所有属性值比较相等性
- 可以被替换

```csharp
public class Address : ValueObject
{
    public string Street { get; }
    public string City { get; }
    public string ZipCode { get; }

    public Address(string street, string city, string zipCode)
    {
        Street = street;
        City = city;
        ZipCode = zipCode;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Street;
        yield return City;
        yield return ZipCode;
    }
}
```

## 仓储模式

### 仓储的职责

仓储封装了数据访问逻辑，提供类似集合的接口：

```csharp
public interface IRepository<TAggregateRoot, TKey>
{
    Task<TAggregateRoot> FindAsync(TKey id);
    Task AddAsync(TAggregateRoot aggregateRoot);
    Task UpdateAsync(TAggregateRoot aggregateRoot);
    Task DeleteAsync(TAggregateRoot aggregateRoot);
    Task<int> SaveChangesAsync();
}
```

### 仓储只针对聚合根

❌ 错误做法：

```csharp
// 不要为内部实体创建仓储
public interface IOrderItemRepository : IRepository<OrderItem, int>
{
}
```

✅ 正确做法：

```csharp
// 只为聚合根创建仓储
public interface IOrderRepository : IRepository<Order, int>
{
}

// 通过聚合根访问内部实体
var order = await orderRepository.FindAsync(orderId);
var items = order.Items;  // 通过聚合根访问
```

### 仓储自动注册

MiCake 会自动为聚合根创建仓储实现：

```csharp
public class MyAppModule : MiCakeModule
{
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        // 扫描程序集，为所有聚合根创建仓储
        context.AutoRegisterRepositories(typeof(MyAppModule).Assembly);
    }
}
```

## 领域事件

### 事件驱动架构

领域事件用于捕获领域中发生的重要业务事件：

```csharp
// 1. 定义事件
public class OrderPlacedEvent : IDomainEvent
{
    public int OrderId { get; }
    public decimal TotalAmount { get; }

    public OrderPlacedEvent(int orderId, decimal totalAmount)
    {
        OrderId = orderId;
        TotalAmount = totalAmount;
    }
}

// 2. 在聚合根中触发事件
public class Order : AggregateRoot<int>
{
    public void PlaceOrder()
    {
        // 业务逻辑
        Status = OrderStatus.Placed;

        // 触发领域事件
        RaiseDomainEvent(new OrderPlacedEvent(Id, TotalAmount));
    }
}

// 3. 处理事件
public class OrderPlacedEventHandler : IDomainEventHandler<OrderPlacedEvent>
{
    public Task HandleAysnc(OrderPlacedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 发送邮件通知
        // 更新库存
        // 记录日志
        return Task.CompletedTask;
    }
}
```

### 事件的自动派发

领域事件会在调用 `SaveChangesAsync` 时自动派发：

```csharp
var order = Order.Create(customer);
order.PlaceOrder();  // 触发事件，但不立即派发

await repository.AddAsync(order);
await repository.SaveChangesAsync();  // 此时自动派发所有事件
```

## 工作单元（Unit of Work）

### 什么是工作单元

工作单元模式用于：
- 跟踪业务操作期间的所有变更
- 确保变更作为一个事务提交
- 保证数据一致性

### MiCake 中的工作单元

在 MiCake 中，DbContext 和 Repository 都实现了工作单元模式：

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Customer, int> _customerRepository;

    public async Task PlaceOrder(int customerId, List<OrderItem> items)
    {
        // 所有操作在同一个工作单元中
        var customer = await _customerRepository.FindAsync(customerId);
        var order = Order.Create(customer, items);

        await _orderRepository.AddAsync(order);

        // 一次性提交所有变更
        await _orderRepository.SaveChangesAsync();
        // 此时：
        // 1. 保存订单数据
        // 2. 派发领域事件
        // 3. 更新审计字段
        // 4. 作为一个事务提交
    }
}
```

## 依赖注入

### 自动服务注册

MiCake 支持通过接口标记自动注册服务：

```csharp
// 标记为瞬时服务（Transient）
public class MyService : ITransientService
{
    // 自动注册为 Transient 生命周期
}

// 标记为作用域服务（Scoped）
public class OrderService : IScopedService
{
    // 自动注册为 Scoped 生命周期
}

// 标记为单例服务（Singleton）
public class CacheService : ISingletonService
{
    // 自动注册为 Singleton 生命周期
}
```

### 手动服务注册

也可以在模块中手动注册：

```csharp
public class MyModule : MiCakeModule
{
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        context.Services.AddTransient<IMyService, MyService>();
        context.Services.AddScoped<IOrderService, OrderService>();
        context.Services.AddSingleton<ICacheService, CacheService>();
    }
}
```

## 审计功能

### 自动审计字段

MiCake 可以自动管理审计字段：

```csharp
public class Product : AggregateRoot<int>, IHasCreationTime, IHasModificationTime
{
    public string Name { get; set; }
    
    // 自动填充的审计字段
    public DateTime CreatedTime { get; set; }
    public DateTime? ModifiedTime { get; set; }
}
```

实体在保存时会自动填充这些字段：
- `CreatedTime`：首次创建时自动设置
- `ModifiedTime`：每次修改时自动更新

### 启用审计

```csharp
services.AddMiCakeWithDefault<MyAppModule, MyDbContext>(options =>
{
    options.AuditConfig = audit =>
    {
        audit.Enable = true;  // 启用审计
    };
});
```

## 软删除

### 逻辑删除 vs 物理删除

- **物理删除**：从数据库中真正删除记录
- **逻辑删除**：只标记为已删除，数据仍保留

```csharp
public class Product : AggregateRoot<int>, ISoftDelete
{
    public string Name { get; set; }
    
    // 软删除字段
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }
}
```

使用软删除后：

```csharp
// 删除产品（逻辑删除）
await repository.DeleteAsync(product);
await repository.SaveChangesAsync();
// IsDeleted 自动设置为 true
// DeletedTime 自动设置为当前时间

// 查询时自动过滤已删除的数据
var products = await repository.GetListAsync();
// 只返回 IsDeleted = false 的数据
```

## 统一返回格式

### 数据包装器

MiCake 可以自动包装 API 响应：

```csharp
// Controller 返回原始数据
[HttpGet("{id}")]
public async Task<Product> GetProduct(int id)
{
    return await repository.FindAsync(id);
}

// 实际 HTTP 响应（自动包装）
{
  "code": "200",
  "message": "Success",
  "data": {
    "id": 1,
    "name": "Product A",
    "price": 99.99
  }
}
```

### 配置数据包装器

```csharp
services.AddMiCakeWithDefault<MyAppModule, MyDbContext>(options =>
{
    options.AspNetConfig = asp =>
    {
        asp.UseDataWrapper = true;
        asp.DataWrapperOptions.SuccessCode = "200";
        asp.DataWrapperOptions.SuccessMessage = "Success";
        asp.DataWrapperOptions.ErrorCode = "500";
    };
});
```

## 异常处理

### 领域异常

使用 `DomainException` 抛出业务逻辑异常：

```csharp
public class Order : AggregateRoot<int>
{
    public void Cancel()
    {
        if (Status == OrderStatus.Shipped)
        {
            throw new DomainException("Cannot cancel shipped order");
        }
        
        Status = OrderStatus.Cancelled;
    }
}
```

### 全局异常处理

MiCake 提供全局异常处理机制，自动将异常转换为统一的错误响应：

```json
{
  "code": "500",
  "message": "Cannot cancel shipped order",
  "data": null
}
```

## 最佳实践总结

### 1. 聚合设计原则
- 保持聚合小而专注
- 通过聚合根访问内部实体
- 在聚合边界内保证一致性
- 跨聚合通过领域事件通信

### 2. 仓储使用原则
- 只为聚合根创建仓储
- 仓储操作应该是原子的
- 在一个工作单元内完成相关操作
- 使用领域事件而非直接跨聚合调用

### 3. 事件驱动原则
- 使用领域事件解耦聚合
- 事件命名应该反映业务事实（过去时）
- 事件处理器保持幂等性
- 避免在事件处理器中执行长时间操作

### 4. 服务分层
- **领域服务**：核心业务逻辑
- **应用服务**：协调多个聚合的操作
- **基础设施服务**：技术性服务（缓存、日志等）

## 架构图示

```
┌─────────────────────────────────────────────────────┐
│                  表现层 (Presentation)                │
│              Controllers / API Endpoints             │
└─────────────────────────┬───────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────┐
│                  应用层 (Application)                 │
│         Application Services / Use Cases            │
└─────────────────────────┬───────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────┐
│                   领域层 (Domain)                     │
│  ┌─────────────┐  ┌──────────────┐  ┌────────────┐ │
│  │ Aggregates  │  │    Events    │  │  Services  │ │
│  └─────────────┘  └──────────────┘  └────────────┘ │
└─────────────────────────┬───────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────┐
│              基础设施层 (Infrastructure)              │
│         Repositories / DbContext / Cache            │
└─────────────────────────────────────────────────────┘
```

## 下一步

现在您已经理解了 MiCake 的核心概念，可以深入学习各个具体组件：

- [实体](./实体.md) - 了解实体的详细用法
- [值对象](./值对象.md) - 学习值对象的设计
- [聚合根](./聚合根.md) - 掌握聚合的设计原则
- [仓储](./仓储.md) - 深入理解仓储模式
- [领域事件](./领域事件.md) - 实现事件驱动架构
