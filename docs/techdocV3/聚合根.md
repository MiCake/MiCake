# 聚合根

聚合根（Aggregate Root）是领域驱动设计中的核心概念。它是聚合的根实体，作为外部访问聚合的唯一入口，负责维护聚合内部的一致性。

## 什么是聚合根

### 聚合的概念

聚合是一组相关对象的集合，被视为数据修改的单元。聚合由一个根实体（聚合根）和多个内部实体或值对象组成。

```
聚合（Aggregate）
┌────────────────────────────────────┐
│  聚合根 (Aggregate Root)           │ ◄── 外部唯一入口
│  ┌──────────────────────────────┐  │
│  │ Order (聚合根)               │  │
│  │  - OrderId                   │  │
│  │  - CustomerId                │  │
│  │  - Status                    │  │
│  │  - TotalAmount               │  │
│  └──────────────────────────────┘  │
│         │ owns                      │
│         ▼                           │
│  ┌──────────────────────────────┐  │
│  │ OrderItem (内部实体)          │  │
│  │  - ProductId                 │  │
│  │  - Quantity                  │  │
│  │  - Price                     │  │
│  └──────────────────────────────┘  │
└────────────────────────────────────┘
```

### 聚合根的职责

1. **维护不变性**：确保聚合内部的业务规则始终满足
2. **控制访问**：作为聚合的唯一入口，所有修改必须通过聚合根
3. **管理生命周期**：负责内部实体的创建、修改和删除
4. **发布事件**：在重要业务操作时发布领域事件
5. **事务边界**：一个聚合在一个事务中被完整地持久化

## 聚合根基类

在 MiCake 中，聚合根继承自 `AggregateRoot<TKey>` 基类：

```csharp
using MiCake.DDD.Domain;

// 使用 int 类型主键
public class Order : AggregateRoot<int>
{
    private List<OrderItem> _items = new();

    public int CustomerId { get; private set; }
    public OrderStatus Status { get; private set; }
    public DateTime OrderDate { get; private set; }

    // 只读集合，防止外部直接修改
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();

    public decimal TotalAmount => _items.Sum(item => item.TotalPrice);

    // 私有构造函数供 EF Core 使用
    private Order() { }

    // 工厂方法创建聚合根
    public static Order Create(int customerId)
    {
        var order = new Order
        {
            CustomerId = customerId,
            Status = OrderStatus.Draft,
            OrderDate = DateTime.UtcNow
        };

        order.RaiseDomainEvent(new OrderCreatedEvent(order.Id, customerId));
        return order;
    }

    // 通过聚合根管理内部实体
    public void AddItem(int productId, int quantity, decimal price)
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException("Cannot add items to non-draft order");

        if (quantity <= 0)
            throw new DomainException("Quantity must be positive");

        var existingItem = _items.FirstOrDefault(i => i.ProductId == productId);
        if (existingItem != null)
        {
            existingItem.IncreaseQuantity(quantity);
        }
        else
        {
            var newItem = new OrderItem(productId, quantity, price);
            _items.Add(newItem);
        }

        RaiseDomainEvent(new OrderItemAddedEvent(Id, productId, quantity));
    }

    public void RemoveItem(int productId)
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException("Cannot remove items from non-draft order");

        var item = _items.FirstOrDefault(i => i.ProductId == productId);
        if (item != null)
        {
            _items.Remove(item);
            RaiseDomainEvent(new OrderItemRemovedEvent(Id, productId));
        }
    }

    public void Submit()
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException("Only draft orders can be submitted");

        if (!_items.Any())
            throw new DomainException("Cannot submit empty order");

        Status = OrderStatus.Submitted;
        RaiseDomainEvent(new OrderSubmittedEvent(Id, TotalAmount));
    }
}

// 内部实体 - 不是聚合根
public class OrderItem : Entity<int>
{
    public int ProductId { get; private set; }
    public int Quantity { get; private set; }
    public decimal Price { get; private set; }
    public decimal TotalPrice => Quantity * Price;

    private OrderItem() { }

    public OrderItem(int productId, int quantity, decimal price)
    {
        ProductId = productId;
        Quantity = quantity;
        Price = price;
    }

    public void IncreaseQuantity(int amount)
    {
        if (amount <= 0)
            throw new DomainException("Amount must be positive");

        Quantity += amount;
    }
}
```

## 设计聚合根的原则

### 1. 聚合边界设计

聚合应该尽可能小，只包含必须保持一致性的对象：

```csharp
// ✅ 好的设计 - 小聚合
public class Order : AggregateRoot<int>
{
    public int CustomerId { get; private set; }  // 引用，不包含整个 Customer
    private List<OrderItem> _items = new();       // 内部实体
    
    // Order 和 OrderItem 必须保持一致性
    public decimal TotalAmount => _items.Sum(i => i.TotalPrice);
}

// ❌ 不好的设计 - 大聚合
public class Order : AggregateRoot<int>
{
    public Customer Customer { get; private set; }  // 包含整个 Customer 聚合
    public List<Product> Products { get; private set; }  // 包含整个 Product 聚合
    // 聚合过大，难以维护
}
```

### 2. 通过 Id 引用其他聚合

聚合之间通过 ID 引用，而不是直接引用：

```csharp
public class Order : AggregateRoot<int>
{
    // ✅ 通过 ID 引用 Customer 聚合
    public int CustomerId { get; private set; }

    // ❌ 不要直接引用其他聚合根
    // public Customer Customer { get; private set; }

    public void SetCustomer(int customerId)
    {
        CustomerId = customerId;
    }
}
```

### 3. 一个事务修改一个聚合

原则上，一个事务只应该修改一个聚合实例：

```csharp
public class OrderService : IDomainService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Product, int> _productRepository;

    // ✅ 好的做法 - 一个事务修改一个聚合
    public async Task CreateOrder(int customerId, List<OrderItemDto> items)
    {
        var order = Order.Create(customerId);

        foreach (var item in items)
        {
            order.AddItem(item.ProductId, item.Quantity, item.Price);
        }

        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync();
        
        // 通过领域事件通知其他聚合
        // 比如减库存操作在事件处理器中异步执行
    }

    // ❌ 避免 - 一个事务修改多个聚合
    public async Task CreateOrderBad(int customerId, List<OrderItemDto> items)
    {
        var order = Order.Create(customerId);
        await _orderRepository.AddAsync(order);

        // 在同一个事务中修改多个聚合
        foreach (var item in items)
        {
            var product = await _productRepository.FindAsync(item.ProductId);
            product.DecreaseStock(item.Quantity);  // 修改另一个聚合
            await _productRepository.UpdateAsync(product);
        }

        await _orderRepository.SaveChangesAsync();  // 可能导致锁竞争
    }
}
```

### 4. 保护聚合不变性

聚合根负责维护内部的一致性约束：

```csharp
public class BankAccount : AggregateRoot<Guid>
{
    public decimal Balance { get; private set; }
    public decimal DailyWithdrawalLimit { get; private set; }
    private List<Transaction> _todayTransactions = new();

    // 不变性：余额不能为负
    // 不变性：单日取款不能超过限额
    public void Withdraw(decimal amount)
    {
        // 验证不变性
        if (amount > Balance)
            throw new DomainException("Insufficient balance");

        var todayWithdrawals = _todayTransactions
            .Where(t => t.Type == TransactionType.Withdrawal && 
                        t.Date.Date == DateTime.Today)
            .Sum(t => t.Amount);

        if (todayWithdrawals + amount > DailyWithdrawalLimit)
            throw new DomainException("Daily withdrawal limit exceeded");

        // 修改状态
        Balance -= amount;
        _todayTransactions.Add(new Transaction(
            TransactionType.Withdrawal, 
            amount, 
            DateTime.UtcNow
        ));

        RaiseDomainEvent(new MoneyWithdrawnEvent(Id, amount, Balance));
    }
}
```

## 聚合根与仓储

### 仓储只针对聚合根

MiCake 中，仓储只为聚合根创建，不为内部实体创建：

```csharp
// ✅ 为聚合根创建仓储
public interface IOrderRepository : IRepository<Order, int> { }

// ❌ 不要为内部实体创建仓储
// public interface IOrderItemRepository : IRepository<OrderItem, int> { }
```

### 自动注册仓储

在模块中自动注册聚合根的仓储：

```csharp
public class OrderModule : MiCakeModule
{
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        // 自动为程序集中的所有聚合根创建仓储
        context.AutoRegisterRepositories(typeof(OrderModule).Assembly);

        base.ConfigureServices(context);
    }
}
```

### 使用仓储

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;

    public OrderService(IRepository<Order, int> orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public async Task<Order> CreateOrder(int customerId, List<OrderItemDto> items)
    {
        // 创建聚合根
        var order = Order.Create(customerId);

        // 通过聚合根添加内部实体
        foreach (var item in items)
        {
            order.AddItem(item.ProductId, item.Quantity, item.Price);
        }

        // 持久化整个聚合
        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync();

        return order;
    }

    public async Task UpdateOrder(int orderId, List<OrderItemDto> newItems)
    {
        // 加载整个聚合
        var order = await _orderRepository.FindAsync(orderId);
        if (order == null)
            throw new DomainException("Order not found");

        // 通过聚合根修改
        foreach (var item in newItems)
        {
            order.AddItem(item.ProductId, item.Quantity, item.Price);
        }

        // 保存更改
        await _orderRepository.UpdateAsync(order);
        await _orderRepository.SaveChangesAsync();
    }
}
```

## 复杂聚合示例

### 购物车聚合

```csharp
public class ShoppingCart : AggregateRoot<Guid>
{
    private List<CartItem> _items = new();
    private const int MaxItemsCount = 100;
    private const decimal MaxTotalAmount = 999999.99m;

    public int UserId { get; private set; }
    public CartStatus Status { get; private set; }
    public IReadOnlyCollection<CartItem> Items => _items.AsReadOnly();
    public decimal TotalAmount => _items.Sum(i => i.SubTotal);
    public int TotalItems => _items.Sum(i => i.Quantity);

    private ShoppingCart() { }

    public static ShoppingCart Create(int userId)
    {
        return new ShoppingCart
        {
            Id = Guid.NewGuid(),
            UserId = userId,
            Status = CartStatus.Active
        };
    }

    public void AddItem(int productId, string productName, decimal price, int quantity)
    {
        EnsureCartIsActive();
        ValidateItem(productId, price, quantity);

        var existingItem = _items.FirstOrDefault(i => i.ProductId == productId);
        if (existingItem != null)
        {
            var newQuantity = existingItem.Quantity + quantity;
            ValidateQuantity(newQuantity);
            existingItem.UpdateQuantity(newQuantity);
        }
        else
        {
            ValidateItemsCount();
            var item = new CartItem(productId, productName, price, quantity);
            _items.Add(item);
        }

        ValidateTotalAmount();
        RaiseDomainEvent(new ItemAddedToCartEvent(Id, productId, quantity));
    }

    public void RemoveItem(int productId)
    {
        EnsureCartIsActive();

        var item = _items.FirstOrDefault(i => i.ProductId == productId);
        if (item != null)
        {
            _items.Remove(item);
            RaiseDomainEvent(new ItemRemovedFromCartEvent(Id, productId));
        }
    }

    public void UpdateItemQuantity(int productId, int newQuantity)
    {
        EnsureCartIsActive();
        ValidateQuantity(newQuantity);

        var item = _items.FirstOrDefault(i => i.ProductId == productId);
        if (item == null)
            throw new DomainException("Item not found in cart");

        item.UpdateQuantity(newQuantity);
        ValidateTotalAmount();

        RaiseDomainEvent(new CartItemQuantityUpdatedEvent(Id, productId, newQuantity));
    }

    public void Clear()
    {
        EnsureCartIsActive();
        _items.Clear();
        RaiseDomainEvent(new CartClearedEvent(Id));
    }

    public Order Checkout(Address shippingAddress)
    {
        EnsureCartIsActive();

        if (!_items.Any())
            throw new DomainException("Cannot checkout empty cart");

        var order = Order.CreateFromCart(Id, UserId, _items, shippingAddress);
        Status = CartStatus.CheckedOut;

        RaiseDomainEvent(new CartCheckedOutEvent(Id, order.Id));

        return order;
    }

    private void EnsureCartIsActive()
    {
        if (Status != CartStatus.Active)
            throw new DomainException("Cart is not active");
    }

    private void ValidateItem(int productId, decimal price, int quantity)
    {
        if (productId <= 0)
            throw new DomainException("Invalid product ID");
        if (price < 0)
            throw new DomainException("Price cannot be negative");
        ValidateQuantity(quantity);
    }

    private void ValidateQuantity(int quantity)
    {
        if (quantity <= 0)
            throw new DomainException("Quantity must be positive");
        if (quantity > 999)
            throw new DomainException("Quantity too large");
    }

    private void ValidateItemsCount()
    {
        if (_items.Count >= MaxItemsCount)
            throw new DomainException($"Cannot add more than {MaxItemsCount} items");
    }

    private void ValidateTotalAmount()
    {
        if (TotalAmount > MaxTotalAmount)
            throw new DomainException($"Total amount cannot exceed {MaxTotalAmount}");
    }
}

public class CartItem : Entity<int>
{
    public int ProductId { get; private set; }
    public string ProductName { get; private set; }
    public decimal Price { get; private set; }
    public int Quantity { get; private set; }
    public decimal SubTotal => Price * Quantity;

    private CartItem() { }

    public CartItem(int productId, string productName, decimal price, int quantity)
    {
        ProductId = productId;
        ProductName = productName;
        Price = price;
        Quantity = quantity;
    }

    public void UpdateQuantity(int newQuantity)
    {
        Quantity = newQuantity;
    }

    public void UpdatePrice(decimal newPrice)
    {
        Price = newPrice;
    }
}
```

## 聚合设计模式

### 1. 软删除聚合根

```csharp
public class Product : AggregateRoot<int>, ISoftDelete
{
    public string Name { get; private set; }
    public decimal Price { get; private set; }
    
    // 软删除接口
    public bool IsDeleted { get; set; }
    public DateTime? DeletedTime { get; set; }

    public void Delete()
    {
        if (IsDeleted)
            throw new DomainException("Product already deleted");

        IsDeleted = true;
        DeletedTime = DateTime.UtcNow;
        RaiseDomainEvent(new ProductDeletedEvent(Id));
    }

    public void Restore()
    {
        if (!IsDeleted)
            throw new DomainException("Product is not deleted");

        IsDeleted = false;
        DeletedTime = null;
        RaiseDomainEvent(new ProductRestoredEvent(Id));
    }
}
```

### 2. 审计聚合根

```csharp
public class Article : AggregateRoot<int>, IHasCreationTime, IHasModificationTime
{
    public string Title { get; private set; }
    public string Content { get; private set; }
    
    // 审计字段 - 自动填充
    public DateTime CreatedTime { get; set; }
    public DateTime? ModifiedTime { get; set; }

    public void UpdateContent(string newContent)
    {
        Content = newContent;
        // ModifiedTime 会自动更新
    }
}
```

## 最佳实践

### 1. 保持聚合小而专注

```csharp
// ✅ 好的设计
public class Order : AggregateRoot<int>
{
    // 只包含订单相关的数据和行为
    private List<OrderItem> _items;
    public OrderStatus Status { get; private set; }
}

// ❌ 避免大聚合
public class Order : AggregateRoot<int>
{
    public Customer Customer { get; set; }  // 不要包含其他聚合
    public List<Product> Products { get; set; }  // 不要包含其他聚合
    public Invoice Invoice { get; set; }  // 应该是独立的聚合
}
```

### 2. 使用领域事件解耦聚合

```csharp
public class Order : AggregateRoot<int>
{
    public void Submit()
    {
        Status = OrderStatus.Submitted;
        
        // 通过事件通知，而不是直接调用其他聚合
        RaiseDomainEvent(new OrderSubmittedEvent(Id, CustomerId, TotalAmount));
        // 库存扣减在事件处理器中异步执行
    }
}
```

### 3. 聚合根方法应该是原子操作

```csharp
public class Order : AggregateRoot<int>
{
    // ✅ 原子操作
    public void Cancel()
    {
        if (Status == OrderStatus.Shipped)
            throw new DomainException("Cannot cancel shipped order");

        Status = OrderStatus.Cancelled;
        RaiseDomainEvent(new OrderCancelledEvent(Id));
    }

    // ❌ 避免需要多步操作才能完成的方法
    public void StartCancel()
    {
        Status = OrderStatus.Cancelling;
    }

    public void FinishCancel()
    {
        Status = OrderStatus.Cancelled;
    }
}
```

## 小结

聚合根是 DDD 中维护一致性的关键：

- 继承 `AggregateRoot<TKey>` 基类
- 作为聚合的唯一入口
- 维护聚合内部的一致性
- 通过 ID 引用其他聚合
- 一个事务修改一个聚合实例
- 使用领域事件在聚合间通信
- 只为聚合根创建仓储

下一步：
- 学习[仓储](./仓储.md)了解持久化
- 阅读[领域事件](./领域事件.md)理解事件驱动
- 查看[工作单元](./工作单元.md)理解事务管理
