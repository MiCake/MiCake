# 软删除支持

MiCake 提供了软删除功能，允许您标记数据为已删除而不是真正从数据库中删除，便于数据恢复和审计。

## 什么是软删除？

软删除（Soft Delete）是一种逻辑删除方式，不会真正从数据库中删除记录，而是通过一个标记字段（如 `IsDeleted`）来标识该记录已被删除。

**优点：**
- 数据可恢复
- 保留完整的数据历史
- 便于审计和追踪
- 满足某些行业的数据保留要求

## 启用软删除

### 实现软删除接口

实现 `ISoftDeletion` 接口：

```csharp
using MiCake.Audit.SoftDeletion;

public class Product : AggregateRoot<int>, ISoftDeletion
{
    public string Name { get; private set; }
    public decimal Price { get; private set; }
    
    // 软删除标记
    public bool IsDeleted { get; set; }

    private Product() { }

    public static Product Create(string name, decimal price)
    {
        return new Product
        {
            Name = name,
            Price = price,
            IsDeleted = false // 默认未删除
        };
    }
}
```

### 结合审计功能

可以同时使用软删除和审计功能：

```csharp
using MiCake.Audit;
using MiCake.Audit.SoftDeletion;

// 使用组合接口
public class Order : AggregateRoot<int>, IHasAuditWithSoftDeletion
{
    public string OrderNumber { get; private set; }
    
    // 审计字段
    public DateTime CreationTime { get; set; }
    public DateTime? ModificationTime { get; set; }
    
    // 软删除字段
    public bool IsDeleted { get; set; }
    public DateTime? DeletionTime { get; set; }

    private Order() { }
}

// 或分别实现
public class Product : AggregateRoot<int>, IHasAudit, ISoftDeletion
{
    public string Name { get; private set; }
    
    public DateTime CreationTime { get; set; }
    public DateTime? ModificationTime { get; set; }
    public bool IsDeleted { get; set; }
}
```

### 记录删除时间

实现 `IHasDeletionTime` 接口可以记录删除时间：

```csharp
using MiCake.Audit.SoftDeletion;

public class Article : AggregateRoot<int>, ISoftDeletion, IHasDeletionTime
{
    public string Title { get; private set; }
    public string Content { get; private set; }
    
    // 软删除标记
    public bool IsDeleted { get; set; }
    
    // 删除时间
    public DateTime? DeletionTime { get; set; }
}
```

## 软删除操作

### 删除实体

```csharp
[HttpDelete("{id}")]
public async Task<IActionResult> DeleteProduct(int id)
{
    var product = await _productRepository.FindAsync(id);
    if (product == null)
        return NotFound();

    // 软删除（不会真正删除）
    await _productRepository.DeleteAsync(product);
    await _productRepository.SaveChangesAsync();

    // 数据库中 IsDeleted 字段会被设置为 true
    // 如果实现了 IHasDeletionTime，DeletionTime 会被设置为当前时间

    return Ok();
}
```

### 查询过滤

MiCake 会自动过滤已软删除的数据：

```csharp
// 自动过滤已删除的产品
public async Task<List<Product>> GetAllProducts()
{
    // 只返回 IsDeleted = false 的产品
    return await _productRepository.Query()
        .ToListAsync();
}

// 查询指定产品
public async Task<Product?> GetProduct(int id)
{
    // 只有未删除的产品才能被查到
    return await _productRepository.FindAsync(id);
}
```

### 包含已删除数据

如果需要查询包括已删除的数据：

```csharp
public async Task<List<Product>> GetAllProductsIncludingDeleted()
{
    return await _productRepository.Query()
        .IgnoreQueryFilters() // 忽略软删除过滤器
        .ToListAsync();
}

// 只查询已删除的数据
public async Task<List<Product>> GetDeletedProducts()
{
    return await _productRepository.Query()
        .IgnoreQueryFilters()
        .Where(p => p.IsDeleted)
        .ToListAsync();
}
```

### 恢复已删除数据

```csharp
[HttpPost("restore/{id}")]
public async Task<IActionResult> RestoreProduct(int id)
{
    // 查询包括已删除的数据
    var product = await _productRepository.Query()
        .IgnoreQueryFilters()
        .FirstOrDefaultAsync(p => p.Id == id);

    if (product == null)
        return NotFound();

    if (!product.IsDeleted)
        return BadRequest("产品未被删除");

    // 恢复产品
    product.IsDeleted = false;
    
    if (product is IHasDeletionTime deletionTimeEntity)
    {
        deletionTimeEntity.DeletionTime = null;
    }

    await _productRepository.UpdateAsync(product);
    await _productRepository.SaveChangesAsync();

    return Ok();
}
```

### 永久删除

如果需要真正删除数据（物理删除）：

```csharp
[HttpDelete("permanent/{id}")]
public async Task<IActionResult> PermanentlyDeleteProduct(int id)
{
    var product = await _productRepository.Query()
        .IgnoreQueryFilters()
        .FirstOrDefaultAsync(p => p.Id == id);

    if (product == null)
        return NotFound();

    // 使用原生 SQL 或 EF Core 方法直接删除
    _dbContext.Products.Remove(product);
    await _dbContext.SaveChangesAsync();

    return Ok();
}
```

## 配置软删除

### 在 DbContext 中配置

```csharp
using MiCake.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;

public class MyDbContext : MiCakeDbContext
{
    public DbSet<Product> Products { get; set; }
    public DbSet<Order> Orders { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // MiCake 会自动为实现 ISoftDeletion 的实体配置查询过滤器
        // 无需手动配置
    }
}
```

### 全局查询过滤器

MiCake 自动为所有实现 `ISoftDeletion` 的实体添加全局查询过滤器：

```csharp
// MiCake 内部实现（无需手动添加）
modelBuilder.Entity<Product>()
    .HasQueryFilter(e => !e.IsDeleted);

modelBuilder.Entity<Order>()
    .HasQueryFilter(e => !e.IsDeleted);
```

## 软删除最佳实践

### 1. 对重要数据启用软删除

```csharp
// ✅ 重要数据启用软删除
public class Order : AggregateRoot<int>, ISoftDeletion
{
    public bool IsDeleted { get; set; }
}

public class Customer : AggregateRoot<int>, ISoftDeletion
{
    public bool IsDeleted { get; set; }
}

// ⚠️ 日志等临时数据可以不使用软删除
public class ApplicationLog : Entity<int>
{
    // 不实现 ISoftDeletion，可以直接删除
}
```

### 2. 记录删除时间和删除人

```csharp
public interface IHasFullDeletion : ISoftDeletion, IHasDeletionTime
{
    int? DeleterId { get; set; }
}

public class Order : AggregateRoot<int>, IHasFullDeletion
{
    public bool IsDeleted { get; set; }
    public DateTime? DeletionTime { get; set; }
    public int? DeleterId { get; set; }
}
```

### 3. 级联软删除

处理关联实体的软删除：

```csharp
public class Order : AggregateRoot<int>, ISoftDeletion
{
    private readonly List<OrderItem> _items = new();
    
    public bool IsDeleted { get; set; }
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();

    public void SoftDelete()
    {
        IsDeleted = true;
        
        // 级联软删除订单项
        foreach (var item in _items)
        {
            item.IsDeleted = true;
        }
    }
}

public class OrderItem : Entity<int>, ISoftDeletion
{
    public bool IsDeleted { get; set; }
}
```

### 4. 唯一性约束处理

对于有唯一性约束的字段，软删除后可能需要特殊处理：

```csharp
public class User : AggregateRoot<int>, ISoftDeletion
{
    public string Email { get; private set; }
    public bool IsDeleted { get; set; }

    // 在 DbContext 中配置唯一索引
}

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    // 方式 1：唯一索引包含 IsDeleted 字段
    modelBuilder.Entity<User>()
        .HasIndex(e => new { e.Email, e.IsDeleted })
        .IsUnique();

    // 方式 2：使用过滤的唯一索引（SQL Server）
    modelBuilder.Entity<User>()
        .HasIndex(e => e.Email)
        .IsUnique()
        .HasFilter("[IsDeleted] = 0");
}
```

### 5. 定期清理

定期清理长时间软删除的数据：

```csharp
public class DataCleanupService
{
    private readonly MyDbContext _dbContext;

    // 清理 30 天前软删除的数据
    public async Task CleanupOldDeletedData()
    {
        var thirtyDaysAgo = DateTime.UtcNow.AddDays(-30);

        var oldDeletedProducts = await _dbContext.Products
            .IgnoreQueryFilters()
            .Where(p => p.IsDeleted && p.DeletionTime < thirtyDaysAgo)
            .ToListAsync();

        _dbContext.Products.RemoveRange(oldDeletedProducts);
        await _dbContext.SaveChangesAsync();
    }
}
```

## 查询示例

### 统计

```csharp
// 统计未删除的产品数量
public async Task<int> GetActiveProductCount()
{
    return await _productRepository.Query()
        .CountAsync(); // 自动过滤已删除数据
}

// 统计包括已删除的总数
public async Task<int> GetTotalProductCount()
{
    return await _productRepository.Query()
        .IgnoreQueryFilters()
        .CountAsync();
}

// 统计已删除的数量
public async Task<int> GetDeletedProductCount()
{
    return await _productRepository.Query()
        .IgnoreQueryFilters()
        .CountAsync(p => p.IsDeleted);
}
```

### 复杂查询

```csharp
// 查询最近删除的记录
public async Task<List<Product>> GetRecentlyDeleted()
{
    return await _productRepository.Query()
        .IgnoreQueryFilters()
        .Where(p => p.IsDeleted)
        .OrderByDescending(p => (p as IHasDeletionTime).DeletionTime)
        .Take(20)
        .ToListAsync();
}

// 查询可恢复的数据（删除时间在 7 天内）
public async Task<List<Order>> GetRecoverableOrders()
{
    var sevenDaysAgo = DateTime.UtcNow.AddDays(-7);

    return await _orderRepository.Query()
        .IgnoreQueryFilters()
        .Where(o => o.IsDeleted && o.DeletionTime >= sevenDaysAgo)
        .ToListAsync();
}
```

## 注意事项

1. **查询过滤**：软删除的数据默认不会出现在查询结果中
2. **显式包含**：使用 `IgnoreQueryFilters()` 包含已删除数据
3. **唯一约束**：注意处理唯一性约束字段
4. **级联删除**：考虑关联实体的软删除处理
5. **定期清理**：建立定期清理机制，避免数据库膨胀
6. **权限控制**：恢复和永久删除操作应该有适当的权限控制

## 下一步

- 了解[自动审计](./自动审计.md)功能
- 学习[聚合根](./聚合根.md)
- 探索[仓储](./仓储.md)的使用
