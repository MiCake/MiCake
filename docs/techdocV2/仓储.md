# 仓储（Repository）

仓储模式提供了一个集合式的接口来访问聚合根，隐藏了数据访问的复杂性。在 MiCake 中，仓储是操作聚合根的主要方式。

## 什么是仓储？

仓储（Repository）是领域层和数据映射层之间的中介，提供类似内存集合的接口来访问聚合根。它隐藏了数据库访问的技术细节，让领域层专注于业务逻辑。

**核心特点：**
- 只针对聚合根，不针对普通实体
- 提供集合式的接口
- 自动处理领域事件分发
- 集成工作单元

## 仓储接口

MiCake 提供了两个主要的仓储接口：

### IReadOnlyRepository

只读仓储，用于查询操作：

```csharp
public interface IReadOnlyRepository<TAggregateRoot, TKey>
{
    // 查询
    IQueryable<TAggregateRoot> Query();
    
    // 根据 ID 查找
    Task<TAggregateRoot?> FindAsync(TKey id, CancellationToken cancellationToken = default);
    
    // 根据 ID 查找，包含导航属性
    Task<TAggregateRoot?> FindAsync(
        TKey id, 
        Func<IQueryable<TAggregateRoot>, IQueryable<TAggregateRoot>> includeFunc,
        CancellationToken cancellationToken = default);
    
    // 获取总数
    Task<long> GetCountAsync(CancellationToken cancellationToken = default);
}
```

### IRepository

完整的仓储接口，继承自 `IReadOnlyRepository`，增加了修改操作：

```csharp
public interface IRepository<TAggregateRoot, TKey> : IReadOnlyRepository<TAggregateRoot, TKey>
{
    // 添加聚合根
    Task AddAsync(TAggregateRoot aggregateRoot, CancellationToken cancellationToken = default);
    
    // 添加并返回（用于获取自增 ID）
    Task<TAggregateRoot> AddAndReturnAsync(
        TAggregateRoot aggregateRoot, 
        bool saveNow = true, 
        CancellationToken cancellationToken = default);
    
    // 更新聚合根
    Task UpdateAsync(TAggregateRoot aggregateRoot, CancellationToken cancellationToken = default);
    
    // 删除聚合根
    Task DeleteAsync(TAggregateRoot aggregateRoot, CancellationToken cancellationToken = default);
    
    // 根据 ID 删除
    Task DeleteByIdAsync(TKey id, CancellationToken cancellationToken = default);
    
    // 保存更改（触发领域事件）
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
    
    // 清除更改跟踪
    Task ClearChangeTrackingAsync(CancellationToken cancellationToken = default);
}
```

## 使用仓储

### 注册仓储

在模块的 `ConfigureServices` 方法中自动注册仓储：

```csharp
[RelyOn(typeof(MiCakeAspNetCoreModule))]
public class MyAppModule : MiCakeModule
{
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        // 自动注册当前程序集中所有聚合根的仓储
        context.AutoRegisterRepositories(typeof(MyAppModule).Assembly);

        base.ConfigureServices(context);
    }
}
```

### 注入仓储

通过构造函数注入仓储：

```csharp
using MiCake.DDD.Domain;

public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Product, int> _productRepository;

    public OrderService(
        IRepository<Order, int> orderRepository,
        IRepository<Product, int> productRepository)
    {
        _orderRepository = orderRepository;
        _productRepository = productRepository;
    }
}
```

### 查询操作

#### 使用 Query 方法

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;

    // 使用 LINQ 查询
    public async Task<List<Order>> GetPendingOrders()
    {
        return await _orderRepository.Query()
            .Where(o => o.Status == OrderStatus.Pending)
            .OrderByDescending(o => o.CreatedAt)
            .ToListAsync();
    }

    // 复杂查询
    public async Task<List<Order>> GetCustomerOrdersWithItems(int customerId)
    {
        return await _orderRepository.Query()
            .Include(o => o.Items)
            .Where(o => o.CustomerId == customerId)
            .Where(o => o.Status != OrderStatus.Cancelled)
            .ToListAsync();
    }

    // 分页查询
    public async Task<List<Order>> GetOrdersPage(int pageIndex, int pageSize)
    {
        return await _orderRepository.Query()
            .OrderByDescending(o => o.CreatedAt)
            .Skip(pageIndex * pageSize)
            .Take(pageSize)
            .ToListAsync();
    }
}
```

#### 使用 FindAsync 方法

```csharp
// 简单查找
public async Task<Order?> GetOrder(int orderId)
{
    return await _orderRepository.FindAsync(orderId);
}

// 包含导航属性
public async Task<Order?> GetOrderWithItems(int orderId)
{
    return await _orderRepository.FindAsync(
        orderId,
        query => query.Include(o => o.Items)
    );
}

// 处理不存在的情况
public async Task<Order> GetOrderOrThrow(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    if (order == null)
        throw new NotFoundException($"订单 {orderId} 不存在");
    
    return order;
}
```

#### 获取数量

```csharp
public async Task<long> GetTotalOrderCount()
{
    return await _orderRepository.GetCountAsync();
}

// 或使用 LINQ
public async Task<int> GetPendingOrderCount()
{
    return await _orderRepository.Query()
        .Where(o => o.Status == OrderStatus.Pending)
        .CountAsync();
}
```

### 添加操作

```csharp
public async Task<int> CreateOrder(CreateOrderDto dto)
{
    // 创建聚合根
    var order = Order.Create(dto.CustomerId, dto.ShippingAddress);
    
    // 添加订单项
    foreach (var item in dto.Items)
    {
        order.AddItem(item.ProductId, item.ProductName, item.Price, item.Quantity);
    }

    // 添加到仓储
    await _orderRepository.AddAsync(order);
    
    // 保存更改（领域事件在此时自动分发）
    await _orderRepository.SaveChangesAsync();

    return order.Id;
}

// 添加并返回（用于获取自增 ID）
public async Task<Order> CreateAndReturnOrder(CreateOrderDto dto)
{
    var order = Order.Create(dto.CustomerId, dto.ShippingAddress);
    
    foreach (var item in dto.Items)
    {
        order.AddItem(item.ProductId, item.ProductName, item.Price, item.Quantity);
    }

    // 添加并立即保存，返回包含 ID 的实体
    var savedOrder = await _orderRepository.AddAndReturnAsync(order, saveNow: true);

    return savedOrder;
}
```

### 更新操作

```csharp
public async Task UpdateOrder(int orderId, UpdateOrderDto dto)
{
    // 加载聚合根
    var order = await _orderRepository.FindAsync(orderId);
    if (order == null)
        throw new NotFoundException($"订单 {orderId} 不存在");

    // 执行领域操作
    order.UpdateShippingAddress(dto.ShippingAddress);
    order.AddNote(dto.Note);

    // 更新（通常 EF Core 会自动跟踪更改，此调用是可选的）
    await _orderRepository.UpdateAsync(order);
    
    // 保存更改
    await _orderRepository.SaveChangesAsync();
}
```

### 删除操作

```csharp
// 删除聚合根实例
public async Task DeleteOrder(Order order)
{
    await _orderRepository.DeleteAsync(order);
    await _orderRepository.SaveChangesAsync();
}

// 根据 ID 删除
public async Task DeleteOrderById(int orderId)
{
    await _orderRepository.DeleteByIdAsync(orderId);
    await _orderRepository.SaveChangesAsync();
}
```

## SaveChangesAsync 和领域事件

`SaveChangesAsync` 是一个关键方法，它不仅保存数据，还会自动分发领域事件：

```csharp
public async Task ConfirmOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    if (order == null)
        throw new NotFoundException("订单不存在");

    // 触发领域事件
    order.Confirm(); // 内部调用 RaiseDomainEvent

    // 保存更改时，自动执行以下操作：
    // 1. 保存实体更改到数据库
    // 2. 收集所有领域事件
    // 3. 分发领域事件给相应的处理器
    // 4. 清除领域事件
    await _orderRepository.SaveChangesAsync();
}
```

**执行流程：**

```
1. 调用 SaveChangesAsync()
2. 收集聚合根中的所有领域事件
3. 保存实体更改到数据库
4. 按顺序分发领域事件
5. 清除聚合根中的领域事件
6. 返回受影响的行数
```

## 仓储最佳实践

### 1. 仓储只针对聚合根

```csharp
// ✅ 正确：为聚合根创建仓储
public class Order : AggregateRoot<int> { }
IRepository<Order, int> orderRepository;

// ❌ 错误：不要为聚合内的实体创建仓储
public class OrderItem : Entity<int> { }
// 不应该有：IRepository<OrderItem, int>
```

### 2. 通过聚合根访问聚合内对象

```csharp
// ✅ 正确：通过聚合根访问
var order = await _orderRepository.FindAsync(orderId);
var items = order.Items; // 通过聚合根获取订单项

// ❌ 错误：直接查询聚合内对象
// var items = await _orderItemRepository.Query()...
```

### 3. 使用工作单元管理事务

```csharp
[HttpPost]
[UnitOfWork] // 自动管理事务
public async Task<IActionResult> CreateOrder([FromBody] CreateOrderDto dto)
{
    var order = Order.Create(dto.CustomerId, dto.ShippingAddress);
    
    await _orderRepository.AddAsync(order);
    await _orderRepository.SaveChangesAsync();

    return Ok(order.Id);
}
```

### 4. 避免在循环中调用 SaveChangesAsync

```csharp
// ❌ 错误：在循环中保存
public async Task CreateMultipleOrders(List<CreateOrderDto> dtos)
{
    foreach (var dto in dtos)
    {
        var order = Order.Create(dto.CustomerId, dto.ShippingAddress);
        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync(); // 每次都提交事务
    }
}

// ✅ 正确：批量操作
public async Task CreateMultipleOrders(List<CreateOrderDto> dtos)
{
    foreach (var dto in dtos)
    {
        var order = Order.Create(dto.CustomerId, dto.ShippingAddress);
        await _orderRepository.AddAsync(order);
    }
    
    await _orderRepository.SaveChangesAsync(); // 一次性提交
}
```

### 5. 处理并发冲突

```csharp
public async Task UpdateProduct(int productId, UpdateProductDto dto)
{
    try
    {
        var product = await _productRepository.FindAsync(productId);
        if (product == null)
            throw new NotFoundException("产品不存在");

        product.Update(dto.Name, dto.Price);
        await _productRepository.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException)
    {
        throw new ConcurrencyException("产品已被其他用户修改，请刷新后重试");
    }
}
```

## 只读仓储

当您只需要查询功能时，可以使用只读仓储：

```csharp
public class OrderQueryService
{
    private readonly IReadOnlyRepository<Order, int> _orderRepository;

    public OrderQueryService(IReadOnlyRepository<Order, int> orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public async Task<List<OrderSummaryDto>> GetOrderSummaries(int customerId)
    {
        return await _orderRepository.Query()
            .Where(o => o.CustomerId == customerId)
            .Select(o => new OrderSummaryDto
            {
                Id = o.Id,
                OrderNumber = o.OrderNumber,
                TotalAmount = o.TotalAmount,
                Status = o.Status
            })
            .ToListAsync();
    }
}
```

## 清除更改跟踪

在某些场景下，您可能需要清除 EF Core 的更改跟踪：

```csharp
public async Task ProcessLargeDataSet()
{
    var orders = await _orderRepository.Query()
        .Where(o => o.Status == OrderStatus.Pending)
        .ToListAsync();

    foreach (var order in orders)
    {
        // 处理订单...
    }

    // 清除更改跟踪，释放内存
    await _orderRepository.ClearChangeTrackingAsync();
}
```

## 仓储内部实现

MiCake 使用工厂模式创建仓储实例：

```csharp
// 仓储通过 IRepositoryFactory 创建
public interface IRepositoryFactory<TAggregateRoot, TKey>
{
    IRepository<TAggregateRoot, TKey> Create();
}

// 实际的数据访问通过 IRepositoryProvider 实现
public interface IRepositoryProvider<TAggregateRoot, TKey>
{
    IQueryable<TAggregateRoot> Query();
    Task<TAggregateRoot?> FindAsync(TKey id);
    Task AddAsync(TAggregateRoot aggregateRoot);
    Task UpdateAsync(TAggregateRoot aggregateRoot);
    Task DeleteAsync(TAggregateRoot aggregateRoot);
    Task<int> SaveChangesAsync();
}
```

## 注意事项

1. **仅针对聚合根**：不要为聚合内的实体创建仓储
2. **SaveChangesAsync 触发事件**：领域事件在 `SaveChangesAsync` 时自动分发
3. **一个事务一个聚合根**：避免在一个事务中修改多个聚合根
4. **使用 Query 进行复杂查询**：充分利用 LINQ 的强大功能
5. **避免过度查询**：使用 `Include` 预加载关联数据，避免 N+1 问题

## 下一步

- 了解[领域事件](./领域事件.md)的自动分发机制
- 学习[工作单元](./工作单元.md)管理事务
- 探索[聚合根](./聚合根.md)的设计原则
