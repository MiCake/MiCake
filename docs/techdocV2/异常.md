# 异常

MiCake 提供了统一的异常处理机制，包括领域异常、业务异常等，并能自动将异常转换为统一的 API 响应格式。

## MiCake 异常体系

### MiCakeException - 基础异常

所有 MiCake 异常的基类：

```csharp
using MiCake.Core;

public class MiCakeException : Exception
{
    // 异常代码
    public virtual string? Code { get; set; }
    
    // 异常详情
    public virtual object? Details { get; set; }

    public MiCakeException(string message, string? details = null, string? code = null)
        : base(message)
    {
        Code = code;
        Details = details;
    }

    public MiCakeException(
        string message, 
        Exception innerException,
        string? details = null,
        string? code = null)
        : base(message, innerException)
    {
        Code = code;
        Details = details;
    }
}
```

### DomainException - 领域异常

用于表示违反领域规则的异常：

```csharp
using MiCake.DDD.Domain;

public class DomainException : MiCakeException
{
    public DomainException(string message) 
        : base(message, code: "DOMAIN_ERROR")
    {
    }

    public DomainException(string message, string code)
        : base(message, code: code)
    {
    }
}
```

## 使用异常

### 在聚合根中

```csharp
public class Order : AggregateRoot<int>
{
    public OrderStatus Status { get; private set; }
    public decimal TotalAmount { get; private set; }

    public void Confirm()
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException("只能确认草稿状态的订单");

        if (TotalAmount <= 0)
            throw new DomainException("订单金额必须大于零");

        if (!Items.Any())
            throw new DomainException("订单至少需要一个商品项");

        Status = OrderStatus.Confirmed;
        RaiseDomainEvent(new OrderConfirmedEvent(Id));
    }

    public void Cancel(string reason)
    {
        if (Status == OrderStatus.Shipped || Status == OrderStatus.Completed)
            throw new DomainException(
                "已发货或已完成的订单不能取消",
                code: "ORDER_CANCEL_NOT_ALLOWED"
            );

        Status = OrderStatus.Cancelled;
        RaiseDomainEvent(new OrderCancelledEvent(Id, reason));
    }
}
```

### 自定义异常

```csharp
// 业务异常
public class BusinessException : MiCakeException
{
    public BusinessException(string message, string? code = null)
        : base(message, code: code ?? "BUSINESS_ERROR")
    {
    }
}

// 验证异常
public class ValidationException : MiCakeException
{
    public List<ValidationError> Errors { get; }

    public ValidationException(string message, List<ValidationError> errors)
        : base(message, details: errors, code: "VALIDATION_ERROR")
    {
        Errors = errors;
    }
}

// 未找到异常
public class NotFoundException : MiCakeException
{
    public NotFoundException(string message)
        : base(message, code: "NOT_FOUND")
    {
    }

    public NotFoundException(string entityName, object id)
        : base($"{entityName} with id {id} was not found", code: "NOT_FOUND")
    {
    }
}

// 并发异常
public class ConcurrencyException : MiCakeException
{
    public ConcurrencyException(string message)
        : base(message, code: "CONCURRENCY_ERROR")
    {
    }
}
```

## 使用自定义异常

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;

    public async Task<Order> GetOrder(int orderId)
    {
        var order = await _orderRepository.FindAsync(orderId);
        
        if (order == null)
            throw new NotFoundException("Order", orderId);

        return order;
    }

    public async Task ConfirmOrder(int orderId)
    {
        var order = await GetOrder(orderId);

        try
        {
            order.Confirm();
            await _orderRepository.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            throw new ConcurrencyException("订单已被其他用户修改，请刷新后重试");
        }
    }

    public async Task CreateOrder(CreateOrderDto dto)
    {
        var validationErrors = ValidateOrder(dto);
        if (validationErrors.Any())
        {
            throw new ValidationException("订单验证失败", validationErrors);
        }

        // 创建订单逻辑...
    }

    private List<ValidationError> ValidateOrder(CreateOrderDto dto)
    {
        var errors = new List<ValidationError>();

        if (dto.CustomerId <= 0)
            errors.Add(new ValidationError("CustomerId", "客户 ID 无效"));

        if (dto.Items == null || !dto.Items.Any())
            errors.Add(new ValidationError("Items", "订单至少需要一个商品项"));

        return errors;
    }
}
```

## 全局异常处理

MiCake 提供了全局异常处理机制，自动将异常转换为统一的 API 响应。

### 异常响应格式

当发生异常时，API 会返回以下格式：

```json
{
  "code": "DOMAIN_ERROR",
  "message": "只能确认草稿状态的订单",
  "errors": null
}
```

对于验证异常：

```json
{
  "code": "VALIDATION_ERROR",
  "message": "订单验证失败",
  "errors": [
    {
      "field": "CustomerId",
      "message": "客户 ID 无效"
    },
    {
      "field": "Items",
      "message": "订单至少需要一个商品项"
    }
  ]
}
```

### HTTP 状态码映射

MiCake 会根据异常类型自动设置 HTTP 状态码：

```csharp
// 默认映射：
// NotFoundException        → 404 Not Found
// ValidationException      → 400 Bad Request
// UnauthorizedException    → 401 Unauthorized
// ForbiddenException       → 403 Forbidden
// DomainException          → 400 Bad Request
// BusinessException        → 400 Bad Request
// 其他异常                  → 500 Internal Server Error
```

## 异常最佳实践

### 1. 使用特定的异常类型

```csharp
// ✅ 正确：使用特定的异常类型
public async Task<Order> GetOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    if (order == null)
        throw new NotFoundException("Order", orderId);
    
    return order;
}

// ❌ 错误：使用通用异常
public async Task<Order> GetOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    if (order == null)
        throw new Exception("Order not found");
    
    return order;
}
```

### 2. 提供清晰的错误消息

```csharp
// ✅ 正确：清晰的错误消息
throw new DomainException("只能确认草稿状态的订单");
throw new ValidationException("邮箱格式不正确");
throw new BusinessException("库存不足，无法完成订单");

// ❌ 错误：模糊的错误消息
throw new Exception("Error");
throw new Exception("Invalid");
throw new Exception("Failed");
```

### 3. 使用错误代码

```csharp
// ✅ 正确：使用错误代码
throw new DomainException("订单不能取消", code: "ORDER_CANCEL_NOT_ALLOWED");
throw new BusinessException("库存不足", code: "INSUFFICIENT_STOCK");

// 客户端可以根据错误代码进行国际化或特殊处理
```

### 4. 包含有用的上下文信息

```csharp
// ✅ 正确：包含上下文信息
throw new DomainException(
    $"产品 '{product.Name}' 的库存不足。当前库存：{product.Stock}，需求数量：{quantity}",
    code: "INSUFFICIENT_STOCK"
);

// ❌ 错误：缺少上下文
throw new DomainException("库存不足");
```

### 5. 不要吞噬异常

```csharp
// ❌ 错误：吞噬异常
try
{
    await ProcessOrder(order);
}
catch (Exception)
{
    // 什么都不做
}

// ✅ 正确：记录并重新抛出
try
{
    await ProcessOrder(order);
}
catch (Exception ex)
{
    _logger.LogError(ex, "处理订单失败: OrderId={OrderId}", order.Id);
    throw;
}

// ✅ 或者转换为更具体的异常
try
{
    await ProcessOrder(order);
}
catch (DbUpdateException ex)
{
    _logger.LogError(ex, "保存订单失败: OrderId={OrderId}", order.Id);
    throw new BusinessException("保存订单失败，请稍后重试");
}
```

## 自定义异常示例

### 权限异常

```csharp
public class UnauthorizedException : MiCakeException
{
    public UnauthorizedException(string message = "未授权访问")
        : base(message, code: "UNAUTHORIZED")
    {
    }
}

public class ForbiddenException : MiCakeException
{
    public ForbiddenException(string message = "没有权限执行此操作")
        : base(message, code: "FORBIDDEN")
    {
    }
}

// 使用
public async Task DeleteOrder(int orderId, int userId)
{
    var order = await GetOrder(orderId);
    
    if (order.CustomerId != userId)
        throw new ForbiddenException("您只能删除自己的订单");

    await _orderRepository.DeleteAsync(order);
    await _orderRepository.SaveChangesAsync();
}
```

### 冲突异常

```csharp
public class ConflictException : MiCakeException
{
    public ConflictException(string message)
        : base(message, code: "CONFLICT")
    {
    }
}

// 使用
public async Task CreateUser(CreateUserDto dto)
{
    var existingUser = await _userRepository.Query()
        .FirstOrDefaultAsync(u => u.Email == dto.Email);

    if (existingUser != null)
        throw new ConflictException("该邮箱已被注册");

    // 创建用户逻辑...
}
```

### 外部服务异常

```csharp
public class ExternalServiceException : MiCakeException
{
    public string ServiceName { get; }

    public ExternalServiceException(string serviceName, string message)
        : base($"外部服务 '{serviceName}' 调用失败: {message}", code: "EXTERNAL_SERVICE_ERROR")
    {
        ServiceName = serviceName;
    }

    public ExternalServiceException(string serviceName, string message, Exception innerException)
        : base($"外部服务 '{serviceName}' 调用失败: {message}", innerException, code: "EXTERNAL_SERVICE_ERROR")
    {
        ServiceName = serviceName;
    }
}

// 使用
public async Task ProcessPayment(Order order)
{
    try
    {
        var result = await _paymentGateway.ChargeAsync(order.TotalAmount);
        if (!result.Success)
            throw new ExternalServiceException("PaymentGateway", result.ErrorMessage);
    }
    catch (HttpRequestException ex)
    {
        throw new ExternalServiceException("PaymentGateway", "网络连接失败", ex);
    }
}
```

## 在控制器中处理异常

虽然 MiCake 提供了全局异常处理，但您仍然可以在控制器中进行特定的异常处理：

```csharp
[ApiController]
[Route("api/[controller]")]
public class OrderController : ControllerBase
{
    private readonly IOrderService _orderService;

    [HttpPost]
    public async Task<IActionResult> CreateOrder([FromBody] CreateOrderDto dto)
    {
        try
        {
            var orderId = await _orderService.CreateOrder(dto);
            return Ok(new { orderId });
        }
        catch (ValidationException ex)
        {
            // 特殊处理验证异常
            return BadRequest(new
            {
                code = ex.Code,
                message = ex.Message,
                errors = ex.Errors
            });
        }
        catch (BusinessException ex)
        {
            // 记录业务异常
            _logger.LogWarning(ex, "创建订单业务异常");
            throw; // 重新抛出，由全局处理
        }
        // 其他异常由全局异常处理器处理
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetOrder(int id)
    {
        try
        {
            var order = await _orderService.GetOrder(id);
            return Ok(order);
        }
        catch (NotFoundException)
        {
            return NotFound(new { message = $"订单 {id} 不存在" });
        }
    }
}
```

## 注意事项

1. **使用特定异常**：创建具体的异常类型而不是使用通用 `Exception`
2. **提供清晰消息**：异常消息应该清晰地说明问题
3. **使用错误代码**：便于客户端进行特殊处理和国际化
4. **不要过度捕获**：只捕获您能处理的异常
5. **记录异常**：在重新抛出前记录异常信息

## 下一步

- 了解[统一返回](./统一返回.md)格式
- 学习[依赖注入](./依赖注入.md)
- 探索[核心概念](./核心概念.md)
