# 工具集

MiCake 提供了一系列实用工具类，帮助您更高效地构建应用程序。这些工具涵盖了缓存、类型转换、查询、弹性处理和数据存储等多个方面。

## 缓存 (BoundedLruCache)

### 简介

`BoundedLruCache<TKey, TValue>` 是一个线程安全的有界 LRU（最近最少使用）缓存，提供高吞吐量和可预测的 LRU 语义。

**特性：**
- 线程安全
- 可配置最大容量
- 支持分段锁（segment）提高并发性能
- 可选无锁近似模式
- 自动淘汰最少使用的项

### 基本使用

```csharp
using MiCake.Util.Cache;

// 创建缓存（最大容量 1000）
var cache = new BoundedLruCache<string, User>(maxSize: 1000);

// 添加或更新
cache.AddOrUpdate("user:1", new User { Id = 1, Name = "张三" });

// 尝试获取
if (cache.TryGetValue("user:1", out var user))
{
    Console.WriteLine($"找到用户: {user.Name}");
}

// 获取或添加（使用工厂方法）
var result = cache.GetOrAdd("user:2", key =>
{
    // 从数据库加载
    return _userRepository.Find(2);
});

// 移除
cache.Remove("user:1");

// 清空所有
cache.Clear();
```

### 高级配置

```csharp
// 使用分段提高并发性能
var cache = new BoundedLruCache<int, Product>(
    maxSize: 10000,
    segments: 16,  // 16 个分段
    useLockFreeApproximation: false  // 使用精确 LRU
);

// 无锁近似模式（更高吞吐量，但牺牲 LRU 精确性）
var fastCache = new BoundedLruCache<string, string>(
    maxSize: 50000,
    segments: 32,
    useLockFreeApproximation: true  // 无锁模式
);
```

### 实际应用场景

#### 用户缓存

```csharp
public class UserService
{
    private readonly BoundedLruCache<int, User> _userCache;
    private readonly IUserRepository _userRepository;

    public UserService(IUserRepository userRepository)
    {
        _userRepository = userRepository;
        _userCache = new BoundedLruCache<int, User>(maxSize: 1000);
    }

    public async Task<User> GetUserAsync(int userId)
    {
        return _userCache.GetOrAdd(userId, async key =>
        {
            // 缓存未命中，从数据库加载
            var user = await _userRepository.FindAsync(key);
            return user ?? throw new UserNotFoundException(key);
        });
    }

    public void InvalidateUser(int userId)
    {
        _userCache.Remove(userId);
    }
}
```

#### 配置缓存

```csharp
public class ConfigurationCache
{
    private readonly BoundedLruCache<string, object> _configCache;

    public ConfigurationCache()
    {
        // 小容量配置缓存，使用单分段保证精确 LRU
        _configCache = new BoundedLruCache<string, object>(
            maxSize: 100,
            segments: 1
        );
    }

    public T GetConfig<T>(string key, Func<string, T> loader)
    {
        return (T)_configCache.GetOrAdd(key, k => loader(k)!);
    }
}
```

## 转换器 (Converter)

### IValueConverter 接口

用于在不同类型之间进行值转换。

```csharp
using MiCake.Util.Convert;

public interface IValueConverter<in TSource, TDestination> 
    where TSource : notnull 
    where TDestination : notnull
{
    bool CanConvert(TSource value);
    TDestination? Convert(TSource value);
}
```

### 自定义转换器

```csharp
// 字符串到整数转换器
public class StringToIntConverter : IValueConverter<string, int>
{
    public bool CanConvert(string value)
    {
        return int.TryParse(value, out _);
    }

    public int? Convert(string value)
    {
        if (int.TryParse(value, out var result))
            return result;
        
        return null;
    }
}

// 使用转换器
var converter = new StringToIntConverter();

if (converter.CanConvert("123"))
{
    var number = converter.Convert("123");
    Console.WriteLine($"转换结果: {number}"); // 123
}
```

### 复杂对象转换

```csharp
// DTO 到实体转换器
public class UserDtoToEntityConverter : IValueConverter<UserDto, User>
{
    public bool CanConvert(UserDto value)
    {
        return value != null && 
               !string.IsNullOrWhiteSpace(value.Email);
    }

    public User? Convert(UserDto value)
    {
        if (!CanConvert(value))
            return null;

        return User.Create(
            value.Email,
            value.Name,
            value.Age
        );
    }
}

// 应用场景
public class UserController : ControllerBase
{
    private readonly IValueConverter<UserDto, User> _converter;
    private readonly IRepository<User> _userRepository;

    [HttpPost]
    public async Task<IActionResult> CreateUser([FromBody] UserDto dto)
    {
        if (!_converter.CanConvert(dto))
            return BadRequest("无效的用户数据");

        var user = _converter.Convert(dto);
        if (user == null)
            return BadRequest("转换失败");

        await _userRepository.AddAsync(user);
        await _userRepository.SaveChangesAsync();

        return Ok();
    }
}
```

## 查询 (Query)

### 分页查询

MiCake 提供了完整的分页查询支持。

#### PagingRequest

```csharp
using MiCake.Util.Query.Paging;

// 基本分页请求
var pagingRequest = new PagingRequest(
    pageIndex: 1,  // 第一页
    pageSize: 20   // 每页 20 条
);

// 获取起始编号
int startNo = pagingRequest.CurrentStartNo; // (1-1) * 20 = 0

// 带额外数据的分页请求
var requestWithData = new PagingRequest<ProductFilterDto>(
    pageIndex: 2,
    pageSize: 10,
    data: new ProductFilterDto { Category = "电子产品" }
);
```

#### PagingResponse

```csharp
public class PagingResponse<T>
{
    public int PageIndex { get; set; }
    public int PageSize { get; set; }
    public int TotalCount { get; set; }
    public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
    public List<T> Items { get; set; } = new();
}
```

#### 分页扩展方法

```csharp
using MiCake.Util.Query.Paging;

public class ProductService
{
    private readonly IRepository<Product> _productRepository;

    // 分页查询产品
    public async Task<PagingResponse<ProductDto>> GetProductsAsync(
        PagingRequest<ProductFilterDto> request)
    {
        var query = _productRepository.Query();

        // 应用筛选条件
        if (!string.IsNullOrWhiteSpace(request.Data.Category))
        {
            query = query.Where(p => p.Category == request.Data.Category);
        }

        // 获取总数
        var totalCount = await query.CountAsync();

        // 分页查询
        var items = await query
            .OrderByDescending(p => p.CreationTime)
            .Skip((request.PageIndex - 1) * request.PageSize)
            .Take(request.PageSize)
            .Select(p => new ProductDto
            {
                Id = p.Id,
                Name = p.Name,
                Price = p.Price
            })
            .ToListAsync();

        return new PagingResponse<ProductDto>
        {
            PageIndex = request.PageIndex,
            PageSize = request.PageSize,
            TotalCount = totalCount,
            Items = items
        };
    }
}
```

#### API 控制器中使用

```csharp
[HttpGet]
public async Task<ActionResult<PagingResponse<ProductDto>>> GetProducts(
    [FromQuery] int pageIndex = 1,
    [FromQuery] int pageSize = 20,
    [FromQuery] string? category = null)
{
    var request = new PagingRequest<ProductFilterDto>(
        pageIndex,
        pageSize,
        new ProductFilterDto { Category = category }
    );

    var response = await _productService.GetProductsAsync(request);
    return Ok(response);
}

// 请求示例: GET /api/products?pageIndex=1&pageSize=20&category=电子产品
```

## 弹性 (Resilience)

### 熔断器 (Circuit Breaker)

MiCake 提供了熔断器模式的实现，用于处理外部服务故障。

#### CircuitBreakerConfig

```csharp
using MiCake.Util.Resilience;

var config = new CircuitBreakerConfig
{
    // 失败阈值（触发熔断的失败次数）
    FailureThreshold = 5,
    
    // 成功阈值（半开状态恢复到关闭状态的成功次数）
    SuccessThreshold = 2,
    
    // 超时时间（单次操作超时）
    Timeout = TimeSpan.FromSeconds(30),
    
    // 半开状态超时（半开状态持续时间）
    HalfOpenTimeout = TimeSpan.FromSeconds(60),
    
    // 选择策略
    SelectionStrategy = ProviderSelectionStrategy.PriorityOrder
};
```

#### 熔断器状态

```csharp
public enum CircuitState
{
    Closed,      // 关闭（正常工作）
    Open,        // 打开（熔断，拒绝请求）
    HalfOpen     // 半开（尝试恢复）
}
```

#### 创建熔断器

```csharp
public interface ICircuitBreakerProvider<TRequest, TResponse>
{
    string ProviderName { get; }
    int Priority { get; }
    Task<TResponse?> ExecuteAsync(TRequest request, CancellationToken cancellationToken);
}

// 实现 HTTP 调用提供者
public class HttpApiProvider : ICircuitBreakerProvider<ApiRequest, ApiResponse>
{
    private readonly HttpClient _httpClient;

    public string ProviderName => "Primary-API";
    public int Priority => 1;

    public async Task<ApiResponse?> ExecuteAsync(
        ApiRequest request, 
        CancellationToken cancellationToken)
    {
        var response = await _httpClient.PostAsJsonAsync(
            "/api/endpoint", 
            request, 
            cancellationToken);
            
        response.EnsureSuccessStatusCode();
        
        return await response.Content.ReadFromJsonAsync<ApiResponse>(
            cancellationToken: cancellationToken);
    }
}

// 创建熔断器
var providers = new List<ICircuitBreakerProvider<ApiRequest, ApiResponse>>
{
    new HttpApiProvider(_primaryHttpClient),
    new HttpApiProvider(_backupHttpClient) { Priority = 2 }
};

var circuitBreaker = new GenericCircuitBreaker<ApiRequest, ApiResponse>(
    providers,
    logger,
    config
);
```

#### 使用熔断器

```csharp
public class PaymentService
{
    private readonly GenericCircuitBreaker<PaymentRequest, PaymentResponse> _circuitBreaker;

    public async Task<PaymentResponse?> ProcessPaymentAsync(PaymentRequest request)
    {
        try
        {
            // 通过熔断器执行请求
            var response = await _circuitBreaker.ExecuteAsync(
                request, 
                CancellationToken.None);
                
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "支付处理失败");
            return null;
        }
    }

    // 检查提供者状态
    public Dictionary<string, (CircuitState State, int Failures, int Successes, int Concurrent)> 
        GetProvidersStatus()
    {
        return _circuitBreaker.GetProvidersStatus();
    }
}
```

#### 多提供者策略

```csharp
// 优先级顺序（按 Priority 排序）
SelectionStrategy = ProviderSelectionStrategy.PriorityOrder

// 轮询（Round Robin）
SelectionStrategy = ProviderSelectionStrategy.RoundRobin

// 最少负载（选择当前并发最少的提供者）
SelectionStrategy = ProviderSelectionStrategy.LeastLoad

// 并行竞速（同时调用所有提供者，返回最快的响应）
SelectionStrategy = ProviderSelectionStrategy.ParallelRace
```

#### 监控和管理

```csharp
[HttpGet("circuit-breaker/status")]
public IActionResult GetCircuitBreakerStatus()
{
    var status = _paymentService.GetProvidersStatus();
    
    return Ok(status.Select(kvp => new
    {
        Provider = kvp.Key,
        State = kvp.Value.State.ToString(),
        Failures = kvp.Value.Failures,
        Successes = kvp.Value.Successes,
        Concurrent = kvp.Value.Concurrent
    }));
}
```

## 存储 (Store)

### DataDepositPool

`DataDepositPool` 是一个线程安全的临时数据存储池，支持容量限制和批量释放。

#### 基本使用

```csharp
using MiCake.Util.Store;

// 创建存储池（最大容量 1000）
var pool = new DataDepositPool(maxCapacity: 1000);

// 存入数据
pool.Store("user:session:123", new UserSession 
{ 
    UserId = 123, 
    LoginTime = DateTime.UtcNow 
});

// 取出数据
var session = pool.TakeOut("user:session:123") as UserSession;

// 检查是否存在
bool exists = pool.Contains("user:session:123");

// 获取当前存储数量
int count = pool.Count;

// 释放所有数据
pool.ReleaseAll();

// 释放资源
pool.Dispose();
```

#### 泛型存储

```csharp
// 存储强类型数据
pool.Store("config:app", new AppConfig { MaxUsers = 1000 });

// 取出时进行类型转换
var config = pool.TakeOut("config:app") as AppConfig;
if (config != null)
{
    Console.WriteLine($"最大用户数: {config.MaxUsers}");
}
```

#### 应用场景

##### 请求上下文存储

```csharp
public class RequestContextMiddleware
{
    private readonly RequestDelegate _next;
    private readonly DataDepositPool _contextPool;

    public RequestContextMiddleware(
        RequestDelegate next,
        DataDepositPool contextPool)
    {
        _next = next;
        _contextPool = contextPool;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var requestId = Guid.NewGuid().ToString();
        
        // 存储请求上下文
        _contextPool.Store(requestId, new RequestContext
        {
            RequestId = requestId,
            UserId = context.User?.FindFirst("sub")?.Value,
            StartTime = DateTime.UtcNow,
            Path = context.Request.Path
        });

        try
        {
            await _next(context);
        }
        finally
        {
            // 请求结束后释放
            _contextPool.TakeOut(requestId);
        }
    }
}
```

##### 临时文件管理

```csharp
public class TempFileManager
{
    private readonly DataDepositPool _filePool;

    public TempFileManager()
    {
        _filePool = new DataDepositPool(maxCapacity: 500);
    }

    public string CreateTempFile(byte[] content)
    {
        var fileId = Guid.NewGuid().ToString();
        var tempPath = Path.Combine(Path.GetTempPath(), fileId);
        
        File.WriteAllBytes(tempPath, content);
        
        // 存储文件路径
        _filePool.Store(fileId, tempPath);
        
        return fileId;
    }

    public string? GetTempFilePath(string fileId)
    {
        return _filePool.TakeOut(fileId) as string;
    }

    public void CleanupAll()
    {
        // 注意：ReleaseAll 不会删除实际文件
        // 需要先遍历删除文件，然后再释放
        _filePool.ReleaseAll();
    }
}
```

##### 缓存预热数据

```csharp
public class CacheWarmupService
{
    private readonly DataDepositPool _warmupPool;
    private readonly IProductRepository _productRepository;

    public async Task WarmupProductCacheAsync()
    {
        // 加载热门产品
        var hotProducts = await _productRepository.Query()
            .OrderByDescending(p => p.ViewCount)
            .Take(100)
            .ToListAsync();

        // 存入预热池
        foreach (var product in hotProducts)
        {
            _warmupPool.Store($"product:{product.Id}", product);
        }

        Console.WriteLine($"预热了 {_warmupPool.Count} 个产品");
    }

    public Product? GetWarmupProduct(int productId)
    {
        return _warmupPool.TakeOut($"product:{productId}") as Product;
    }
}
```

#### 容量管理

```csharp
public class SmartDataPool
{
    private readonly DataDepositPool _pool;

    public SmartDataPool(int maxCapacity = 1000)
    {
        _pool = new DataDepositPool(maxCapacity);
    }

    public bool TryStore(string key, object value)
    {
        // 检查容量
        if (_pool.Count >= _pool.MaxCapacity)
        {
            Console.WriteLine("存储池已满，无法存入新数据");
            return false;
        }

        _pool.Store(key, value);
        return true;
    }

    public void MonitorUsage()
    {
        var usage = (double)_pool.Count / _pool.MaxCapacity * 100;
        Console.WriteLine($"存储池使用率: {usage:F2}%");

        if (usage > 80)
        {
            Console.WriteLine("警告：存储池使用率超过 80%");
        }
    }
}
```

## 其他实用工具

### CheckValue

用于值检查和验证：

```csharp
using MiCake.Util;

// 检查字符串
CheckValue.NotNullOrWhiteSpace(userName, nameof(userName));

// 检查对象
CheckValue.NotNull(user, nameof(user));

// 检查集合
CheckValue.NotNullOrEmpty(items, nameof(items));
```

### RandomHelper

随机值生成工具：

```csharp
using MiCake.Util;

// 生成随机字符串
string randomStr = RandomHelper.GetRandomString(length: 16);

// 生成随机数字
int randomNum = RandomHelper.GetRandomNumber(min: 1, max: 100);

// 生成 GUID
string guid = RandomHelper.GetRandomGuid();
```

### 表达式工具

用于动态构建 LINQ 表达式：

```csharp
using MiCake.Util.Expressions;

// 动态构建查询条件
Expression<Func<Product, bool>> predicate = 
    ExpressionHelper.BuildPredicate<Product>(
        p => p.Price > 100 && p.Category == "电子产品"
    );

var products = await _productRepository.Query()
    .Where(predicate)
    .ToListAsync();
```

## 最佳实践

### 1. 缓存使用建议

```csharp
// ✅ 适合缓存的数据
- 频繁读取、很少修改的数据
- 计算成本高的结果
- 热点数据

// ⚠️ 不适合缓存的数据
- 实时性要求高的数据
- 敏感信息（除非加密）
- 大对象（考虑内存占用）

// 设置合理的容量
var cache = new BoundedLruCache<string, User>(
    maxSize: EstimateOptimalSize()  // 根据实际情况评估
);
```

### 2. 转换器设计

```csharp
// ✅ 良好的转换器设计
public class SafeConverter<TSource, TDestination> 
    : IValueConverter<TSource, TDestination>
{
    public bool CanConvert(TSource value)
    {
        // 先检查是否可转换
        return value != null && ValidateConversion(value);
    }

    public TDestination? Convert(TSource value)
    {
        // 再次验证
        if (!CanConvert(value))
            return default;

        try
        {
            return PerformConversion(value);
        }
        catch
        {
            return default; // 转换失败返回默认值
        }
    }
}
```

### 3. 分页性能优化

```csharp
// ✅ 优化的分页查询
public async Task<PagingResponse<ProductDto>> GetProductsOptimizedAsync(
    PagingRequest request)
{
    // 先获取 ID，减少数据传输
    var ids = await _productRepository.Query()
        .OrderByDescending(p => p.CreationTime)
        .Skip((request.PageIndex - 1) * request.PageSize)
        .Take(request.PageSize)
        .Select(p => p.Id)
        .ToListAsync();

    // 再根据 ID 查询完整数据（可利用缓存）
    var products = await _productRepository.Query()
        .Where(p => ids.Contains(p.Id))
        .Select(p => new ProductDto { ... })
        .ToListAsync();

    // 并行获取总数（如果不需要精确总数，可以缓存）
    var totalCount = await _productRepository.Query().CountAsync();

    return new PagingResponse<ProductDto>
    {
        PageIndex = request.PageIndex,
        PageSize = request.PageSize,
        TotalCount = totalCount,
        Items = products
    };
}
```

### 4. 熔断器配置

```csharp
// ✅ 生产环境推荐配置
var config = new CircuitBreakerConfig
{
    FailureThreshold = 5,              // 5 次失败触发熔断
    SuccessThreshold = 2,              // 2 次成功恢复
    Timeout = TimeSpan.FromSeconds(30), // 30 秒超时
    HalfOpenTimeout = TimeSpan.FromSeconds(60), // 60 秒后尝试恢复
    SelectionStrategy = ProviderSelectionStrategy.PriorityOrder
};

// 配置多个提供者
var providers = new List<ICircuitBreakerProvider<Request, Response>>
{
    new PrimaryProvider { Priority = 1 },      // 主服务
    new BackupProvider { Priority = 2 },       // 备用服务
    new FallbackProvider { Priority = 3 }      // 降级服务
};
```

### 5. 存储池管理

```csharp
// ✅ 正确的存储池使用
public class RequestScopedDataPool : IDisposable
{
    private readonly DataDepositPool _pool;

    public RequestScopedDataPool()
    {
        _pool = new DataDepositPool(maxCapacity: 100);
    }

    public void Store(string key, object value)
    {
        // 检查容量
        if (_pool.Count >= _pool.MaxCapacity)
        {
            // 清理旧数据或拒绝存储
            _pool.ReleaseAll();
        }

        _pool.Store(key, value);
    }

    public void Dispose()
    {
        // 请求结束时释放所有数据
        _pool.ReleaseAll();
        _pool.Dispose();
    }
}
```

## 总结

MiCake 工具集提供了丰富的实用功能：

- **BoundedLruCache**：高性能线程安全缓存
- **IValueConverter**：灵活的类型转换
- **分页查询**：完整的分页支持
- **熔断器**：可靠的服务调用保护
- **DataDepositPool**：临时数据存储

合理使用这些工具可以显著提高应用程序的性能和可靠性。

## 下一步

- 了解[依赖注入](./依赖注入.md)
- 学习[异常处理](./异常.md)
- 探索[模块使用](./模块使用.md)
