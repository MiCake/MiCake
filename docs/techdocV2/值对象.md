# 值对象（Value Object）

值对象是 DDD 中用于描述事物特征的不可变对象，它们通过属性值来判断相等性，而不是标识符。

## 什么是值对象？

值对象是没有唯一标识的领域对象，两个值对象如果所有属性值都相同，则认为它们是相等的。值对象强调不可变性，一旦创建就不能修改。

**常见的值对象：**
- 金额（Money）
- 地址（Address）
- 日期范围（DateRange）
- 颜色（Color）
- 坐标（Coordinate）

## 定义值对象

MiCake 提供两种方式定义值对象：

### 方式 1：继承 ValueObject

```csharp
using MiCake.DDD.Domain;
using System.Collections.Generic;

public class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency ?? throw new ArgumentNullException(nameof(currency));
    }

    // 定义哪些属性用于相等性比较
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }

    // 值对象的领域行为
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new DomainException("不能对不同货币进行加法运算");

        return new Money(Amount + other.Amount, Currency);
    }

    public Money Multiply(decimal multiplier)
    {
        return new Money(Amount * multiplier, Currency);
    }

    public override string ToString()
    {
        return $"{Amount} {Currency}";
    }
}
```

### 方式 2：使用 RecordValueObject（推荐）

C# 9.0 引入的 Record 类型天然适合作为值对象。MiCake 提供了 `RecordValueObject` 基类：

```csharp
using MiCake.DDD.Domain;

public record Address : RecordValueObject
{
    public string Street { get; init; }
    public string City { get; init; }
    public string State { get; init; }
    public string ZipCode { get; init; }

    public Address(string street, string city, string state, string zipCode)
    {
        Street = street;
        City = city;
        State = state;
        ZipCode = zipCode;
    }
}
```

使用 Record 的优势：
- 自动实现值相等性
- 简洁的语法
- 内置的解构支持
- 非破坏性变更（with 表达式）

## 值对象特性

### 1. 值相等性

值对象通过属性值判断相等：

```csharp
var money1 = new Money(100, "USD");
var money2 = new Money(100, "USD");
var money3 = new Money(100, "EUR");

// money1 和 money2 相等（所有属性值相同）
Console.WriteLine(money1.Equals(money2)); // true
Console.WriteLine(money1 == money2);      // true

// money1 和 money3 不相等（货币不同）
Console.WriteLine(money1.Equals(money3)); // false
Console.WriteLine(money1 == money3);      // false
```

### 2. 不可变性

值对象一旦创建就不能修改：

```csharp
// ✅ 正确：使用只读属性
public class Money : ValueObject
{
    public decimal Amount { get; } // 只有 getter
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }
}

// ❌ 错误：可变的值对象
public class Money : ValueObject
{
    public decimal Amount { get; set; } // 有 setter
    public string Currency { get; set; }
}
```

如果需要"修改"值对象，应该创建新的实例：

```csharp
public class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    // 返回新的 Money 实例，而不是修改当前实例
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new DomainException("货币类型必须相同");

        return new Money(Amount + other.Amount, Currency);
    }
}

// 使用
var money1 = new Money(100, "USD");
var money2 = new Money(50, "USD");
var total = money1.Add(money2); // 创建新实例
```

### 3. GetHashCode

值对象正确实现了 `GetHashCode`，可以作为字典键或集合元素：

```csharp
var moneySet = new HashSet<Money>
{
    new Money(100, "USD"),
    new Money(100, "USD"), // 重复，不会添加
    new Money(200, "USD")
};

Console.WriteLine(moneySet.Count); // 输出: 2
```

## 值对象设计最佳实践

### 1. 明确相等性组件

在 `GetEqualityComponents` 中返回所有用于判断相等的属性：

```csharp
public class DateRange : ValueObject
{
    public DateTime Start { get; }
    public DateTime End { get; }

    public DateRange(DateTime start, DateTime end)
    {
        if (start > end)
            throw new DomainException("开始日期不能晚于结束日期");

        Start = start;
        End = end;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Start;
        yield return End;
    }
}
```

### 2. 在构造函数中验证

确保值对象始终处于有效状态：

```csharp
public class Email : ValueObject
{
    public string Value { get; }

    public Email(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new DomainException("邮箱地址不能为空");

        if (!IsValidEmail(value))
            throw new DomainException("邮箱地址格式不正确");

        Value = value;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Value;
    }

    private static bool IsValidEmail(string email)
    {
        // 邮箱验证逻辑
        return email.Contains("@");
    }
}
```

### 3. 包含领域行为

值对象可以包含与自身相关的领域行为：

```csharp
public class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }

    // 领域行为
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new DomainException("不能对不同货币进行运算");

        return new Money(Amount + other.Amount, Currency);
    }

    public Money Subtract(Money other)
    {
        if (Currency != other.Currency)
            throw new DomainException("不能对不同货币进行运算");

        return new Money(Amount - other.Amount, Currency);
    }

    public Money Multiply(decimal factor)
    {
        return new Money(Amount * factor, Currency);
    }

    public bool IsZero() => Amount == 0;
    
    public bool IsPositive() => Amount > 0;
    
    public bool IsNegative() => Amount < 0;
}
```

### 4. 使用 Record 简化代码

对于简单的值对象，使用 Record 可以大大简化代码：

```csharp
// 传统方式（约 30 行）
public class Coordinate : ValueObject
{
    public double Latitude { get; }
    public double Longitude { get; }

    public Coordinate(double latitude, double longitude)
    {
        Latitude = latitude;
        Longitude = longitude;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Latitude;
        yield return Longitude;
    }
}

// 使用 Record（约 10 行）
public record Coordinate(double Latitude, double Longitude) : RecordValueObject
{
    // 可选：添加验证
    public Coordinate(double latitude, double longitude) : this()
    {
        if (latitude < -90 || latitude > 90)
            throw new DomainException("纬度必须在 -90 到 90 之间");
        
        if (longitude < -180 || longitude > 180)
            throw new DomainException("经度必须在 -180 到 180 之间");
    }
}
```

## 使用 Record 的高级特性

### with 表达式（非破坏性变更）

```csharp
public record Address(
    string Street,
    string City,
    string State,
    string ZipCode
) : RecordValueObject;

// 使用 with 创建修改后的副本
var address1 = new Address("123 Main St", "Seattle", "WA", "98101");
var address2 = address1 with { Street = "456 Oak Ave" };

// address1 没有改变
Console.WriteLine(address1.Street); // "123 Main St"
Console.WriteLine(address2.Street); // "456 Oak Ave"
```

### 解构

```csharp
public record Money(decimal Amount, string Currency) : RecordValueObject;

var money = new Money(100, "USD");

// 解构
var (amount, currency) = money;
Console.WriteLine($"{amount} {currency}"); // "100 USD"
```

## 实体中使用值对象

值对象通常作为实体的属性：

```csharp
public class Product : AggregateRoot<int>
{
    public string Name { get; private set; }
    
    // 使用值对象
    public Money Price { get; private set; }
    
    public Dimension Dimension { get; private set; }

    private Product() { }

    public static Product Create(string name, Money price, Dimension dimension)
    {
        return new Product
        {
            Name = name,
            Price = price,
            Dimension = dimension
        };
    }

    public void ChangePrice(Money newPrice)
    {
        Price = newPrice;
        RaiseDomainEvent(new ProductPriceChangedEvent(Id, newPrice));
    }

    public void UpdateDimension(Dimension newDimension)
    {
        Dimension = newDimension;
    }
}

public record Dimension(decimal Length, decimal Width, decimal Height) : RecordValueObject
{
    public decimal Volume => Length * Width * Height;
}
```

## 常见值对象示例

### 金额

```csharp
public class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }

    public static Money operator +(Money left, Money right)
    {
        if (left.Currency != right.Currency)
            throw new DomainException("货币类型必须相同");
        
        return new Money(left.Amount + right.Amount, left.Currency);
    }
}
```

### 地址

```csharp
public record Address : RecordValueObject
{
    public string Street { get; init; }
    public string City { get; init; }
    public string State { get; init; }
    public string ZipCode { get; init; }
    public string Country { get; init; }

    public Address(string street, string city, string state, string zipCode, string country)
    {
        Street = street;
        City = city;
        State = state;
        ZipCode = zipCode;
        Country = country;
    }

    public string FullAddress => $"{Street}, {City}, {State} {ZipCode}, {Country}";
}
```

### 日期范围

```csharp
public record DateRange(DateTime Start, DateTime End) : RecordValueObject
{
    public DateRange(DateTime start, DateTime end) : this()
    {
        if (start > end)
            throw new DomainException("开始日期不能晚于结束日期");
    }

    public int Days => (End - Start).Days;
    
    public bool Contains(DateTime date) => date >= Start && date <= End;
    
    public bool Overlaps(DateRange other) =>
        Start <= other.End && End >= other.Start;
}
```

## 值对象 vs 实体

| 特性 | 值对象 | 实体 |
|------|--------|------|
| 唯一标识 | ❌ 无 | ✅ 有 |
| 相等性判断 | 属性值 | 标识符 |
| 可变性 | 不可变 | 可变 |
| 生命周期 | 依附于实体 | 独立 |
| 示例 | 金额、地址、日期范围 | 用户、订单、产品 |

## 注意事项

1. **始终保持不可变**：值对象一旦创建就不应该修改
2. **实现 GetEqualityComponents**：继承 `ValueObject` 时必须实现此方法
3. **在构造函数中验证**：确保值对象始终有效
4. **优先使用 Record**：对于简单值对象，Record 语法更简洁
5. **不要有标识符**：值对象不应该有 ID 属性

## 下一步

- 了解[实体](./实体.md)
- 学习[聚合根](./聚合根.md)
- 探索如何在[仓储](./仓储.md)中使用值对象
