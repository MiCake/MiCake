# 核心概念

本文介绍 MiCake 框架的核心概念和设计原则，帮助您更好地理解和使用框架。

## 模块系统

MiCake 采用模块化架构，所有功能都围绕模块系统构建。

### 什么是模块？

模块是 MiCake 应用的基本构建单元。每个模块都是一个独立的功能单元，可以：

- 配置自己的服务
- 声明对其他模块的依赖
- 在应用生命周期的不同阶段执行初始化逻辑

### 模块生命周期

模块具有三个主要的生命周期方法：

```csharp
public class MyModule : MiCakeModule
{
    // 1. 配置服务（在应用启动时调用）
    public override void ConfigureServices(ModuleConfigServiceContext context)
    {
        // 注册服务到 DI 容器
        context.Services.AddScoped<IMyService, MyService>();
    }

    // 2. 初始化（在应用启动后调用）
    public override void Initialization(ModuleInitializationContext context)
    {
        // 执行初始化逻辑
    }

    // 3. 关闭（在应用关闭时调用）
    public override void Shutdown()
    {
        // 清理资源
    }
}
```

### 模块依赖

使用 `[RelyOn]` 特性声明模块间的依赖关系：

```csharp
[RelyOn(typeof(MiCakeAspNetCoreModule))]
public class MyAppModule : MiCakeModule
{
    // ...
}
```

MiCake 会自动解析依赖关系，确保模块按正确的顺序初始化。

## 领域驱动设计（DDD）

MiCake 提供了完整的 DDD 战术模式实现。

### 实体（Entity）

实体是具有唯一标识的领域对象，通过 ID 区分：

```csharp
public class Product : Entity<int>
{
    public string Name { get; private set; }
    public decimal Price { get; private set; }
}
```

**特点：**
- 通过 ID 比较相等性
- 可以包含领域事件
- 支持审计字段

### 值对象（Value Object）

值对象是没有标识的不可变对象，通过属性值比较：

```csharp
public class Money : ValueObject
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Amount;
        yield return Currency;
    }
}
```

**特点：**
- 不可变
- 通过值比较相等性
- 无标识符

### 聚合根（Aggregate Root）

聚合根是聚合的根实体，是仓储操作的入口：

```csharp
public class Order : AggregateRoot<int>
{
    private List<OrderItem> _items = new();
    
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    public decimal TotalAmount { get; private set; }

    public void AddItem(Product product, int quantity)
    {
        var item = new OrderItem(product, quantity);
        _items.Add(item);
        RecalculateTotal();
        
        RaiseDomainEvent(new OrderItemAddedEvent(Id, item));
    }
}
```

**特点：**
- 聚合的唯一对外接口
- 负责维护聚合内的业务规则
- 仓储只能操作聚合根

### 仓储（Repository）

仓储提供聚合根的持久化操作：

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;

    public async Task CreateOrder(OrderDto dto)
    {
        var order = Order.Create(dto.CustomerId);
        foreach (var item in dto.Items)
        {
            order.AddItem(item.Product, item.Quantity);
        }

        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync(); // 领域事件在此时自动分发
    }
}
```

**特点：**
- 仅针对聚合根
- 自动处理领域事件分发
- 集成工作单元

### 领域事件（Domain Event）

领域事件用于解耦领域逻辑：

```csharp
public class OrderCreatedEvent : DomainEvent
{
    public int OrderId { get; }
    public string CustomerId { get; }

    public OrderCreatedEvent(int orderId, string customerId)
    {
        OrderId = orderId;
        CustomerId = customerId;
    }
}

// 事件处理器
public class OrderCreatedEventHandler : IDomainEventHandler<OrderCreatedEvent>
{
    public async Task Handle(OrderCreatedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 处理订单创建后的逻辑
        // 例如：发送通知、更新库存等
    }
}
```

**特点：**
- 在 `SaveChangesAsync` 时自动分发
- 支持多个处理器
- 有助于实现最终一致性

### 领域服务（Domain Service）

领域服务用于实现跨多个聚合的业务逻辑：

```csharp
public interface IOrderPricingService : IDomainService
{
    decimal CalculateTotal(Order order);
    decimal ApplyDiscount(Order order, DiscountPolicy policy);
}

public class OrderPricingService : IOrderPricingService
{
    public decimal CalculateTotal(Order order)
    {
        // 复杂的定价逻辑
    }

    public decimal ApplyDiscount(Order order, DiscountPolicy policy)
    {
        // 折扣计算逻辑
    }
}
```

## 依赖注入增强

MiCake 扩展了标准的 .NET Core 依赖注入。

### 自动注册

实现以下接口的服务会自动注册：

```csharp
// 瞬时服务
public class MyService : ITransientService
{
    // ...
}

// 作用域服务
public class MyService : IScopedService
{
    // ...
}

// 单例服务
public class MyService : ISingletonService
{
    // ...
}
```

### 特性注册

使用 `[InjectService]` 特性精确控制注册：

```csharp
[InjectService(ServiceLifetime.Scoped, TryRegister = true)]
public class MyService : IMyService
{
    // ...
}
```

## 工作单元（Unit of Work）

MiCake 自动处理工作单元，无需手动管理事务：

```csharp
[ApiController]
[Route("api/[controller]")]
public class OrderController : ControllerBase
{
    [HttpPost]
    [UnitOfWork] // 自动开启工作单元
    public async Task<IActionResult> CreateOrder([FromBody] OrderDto dto)
    {
        // 所有仓储操作都在同一事务中
        // 方法成功完成时自动提交，异常时自动回滚
    }
}
```

## 统一返回格式

MiCake 自动包装 API 返回结果：

```csharp
[HttpGet("{id}")]
public async Task<Order> GetOrder(int id)
{
    return await _orderRepository.FindAsync(id);
}

// 实际返回：
// {
//   "code": "200",
//   "message": "Success",
//   "data": { "id": 1, ... }
// }
```

## 异常处理

框架提供全局异常处理机制：

```csharp
public class DomainException : MiCakeException
{
    public DomainException(string message) 
        : base(message, code: "DOMAIN_ERROR")
    {
    }
}

// 异常会自动转换为统一的错误响应
// {
//   "code": "DOMAIN_ERROR",
//   "message": "错误信息",
//   "errors": [...]
// }
```

## 审计功能

实现 `IHasAudit` 接口自动记录审计信息：

```csharp
public class Product : AggregateRoot<int>, IHasAudit
{
    public string Name { get; set; }
    
    // 自动填充
    public DateTime CreationTime { get; set; }
    public DateTime? ModificationTime { get; set; }
}
```

## 软删除

实现 `ISoftDeletion` 接口启用软删除：

```csharp
public class Product : AggregateRoot<int>, ISoftDeletion
{
    public string Name { get; set; }
    
    // 软删除标记
    public bool IsDeleted { get; set; }
}

// 删除时只标记为已删除，不实际删除记录
await _productRepository.DeleteAsync(product);
```

## 设计原则

### 轻柔性

MiCake 设计为"薄薄的一层"，不强制改变您的编程风格。

### 非侵入性

您可以在不使用 DDD 功能的情况下使用 MiCake 的其他功能。

### 模块化

所有功能都是可选的，通过模块系统按需加载。

### 约定优于配置

框架提供合理的默认配置，减少配置工作量。

## 下一步

- 深入了解[模块使用](./模块使用.md)
- 学习[实体](./实体.md)的详细用法
- 探索[仓储](./仓储.md)模式
- 配置[依赖注入](./依赖注入.md)
