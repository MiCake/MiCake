# 实体（Entity）

实体是领域驱动设计中最基础的领域对象，它具有唯一标识符，并且通过标识符来判断相等性。

## 什么是实体？

在 DDD 中，实体是具有连续性和标识的领域对象。即使实体的属性值发生变化，只要其标识未变，它仍然是同一个实体。

**例如：** 用户、订单、产品等都是典型的实体。即使用户修改了用户名或邮箱，只要 ID 相同，仍然是同一个用户。

## 定义实体

在 MiCake 中，实体需要继承 `Entity<TKey>` 基类：

### 使用整数 ID

```csharp
using MiCake.DDD.Domain;

public class User : Entity<int>
{
    public string UserName { get; private set; }
    public string Email { get; private set; }
    public DateTime RegistrationDate { get; private set; }

    // 私有构造函数，用于 ORM
    private User() { }

    // 工厂方法
    public static User Create(string userName, string email)
    {
        return new User
        {
            UserName = userName,
            Email = email,
            RegistrationDate = DateTime.UtcNow
        };
    }

    // 领域行为
    public void ChangeEmail(string newEmail)
    {
        if (string.IsNullOrWhiteSpace(newEmail))
            throw new DomainException("邮箱不能为空");

        Email = newEmail;
        
        // 触发领域事件
        RaiseDomainEvent(new UserEmailChangedEvent(Id, newEmail));
    }
}
```

### 使用默认整数 ID

MiCake 提供了 `Entity` 基类（默认使用 `int` 作为 ID 类型）：

```csharp
public class Product : Entity  // 等同于 Entity<int>
{
    public string Name { get; private set; }
    public decimal Price { get; private set; }
}
```

### 使用其他类型的 ID

您可以使用任何类型作为实体标识：

```csharp
// 使用 GUID
public class Order : Entity<Guid>
{
    public string OrderNumber { get; private set; }
    public decimal TotalAmount { get; private set; }
}

// 使用字符串
public class Category : Entity<string>
{
    public string Name { get; private set; }
    public string Description { get; private set; }
}
```

## 实体特性

### 1. 唯一标识

每个实体都有一个唯一的 `Id` 属性：

```csharp
public class Product : Entity<int>
{
    // Id 属性由基类提供
    // public virtual TKey Id { get; init; }
}

// 使用
var product = new Product { Id = 1 };
Console.WriteLine(product.Id); // 输出: 1
```

`Id` 使用 `init` 访问器，确保在对象初始化后不可修改，保证实体标识的不变性。

### 2. 相等性比较

实体通过 ID 判断相等性，而不是属性值：

```csharp
var user1 = new User { Id = 1, UserName = "Alice" };
var user2 = new User { Id = 1, UserName = "Bob" };
var user3 = new User { Id = 2, UserName = "Alice" };

// user1 和 user2 相等（ID 相同）
Console.WriteLine(user1.Equals(user2)); // true
Console.WriteLine(user1 == user2);      // true

// user1 和 user3 不相等（ID 不同）
Console.WriteLine(user1.Equals(user3)); // false
Console.WriteLine(user1 == user3);      // false
```

### 3. 领域事件

实体可以触发领域事件来表达领域中发生的重要行为：

```csharp
public class Order : Entity<int>
{
    public OrderStatus Status { get; private set; }

    public void Ship()
    {
        if (Status != OrderStatus.Paid)
            throw new DomainException("只能发货已支付的订单");

        Status = OrderStatus.Shipped;
        
        // 触发领域事件
        RaiseDomainEvent(new OrderShippedEvent(Id, DateTime.UtcNow));
    }
}
```

**领域事件相关方法：**

- `RaiseDomainEvent(IDomainEvent)`: 添加领域事件
- `DomainEvents`: 获取所有待处理的领域事件
- `ClearDomainEvents()`: 清除所有领域事件

领域事件会在调用 `SaveChangesAsync()` 时自动分发。详见[领域事件](./领域事件.md)。

### 4. GetHashCode 和类型检查

MiCake 的实体实现了完整的相等性比较逻辑：

```csharp
public override bool Equals(object? obj)
{
    // 1. null 检查
    if (obj is null or not Entity<TKey>)
        return false;

    // 2. 引用相等
    if (ReferenceEquals(this, obj))
        return true;

    var other = (Entity<TKey>)obj;

    // 3. 默认 ID 检查（未持久化的实体不相等）
    if (HasDefaultId(this) && HasDefaultId(other))
        return false;

    // 4. 类型兼容性检查
    // 允许继承关系的实体进行比较

    // 5. ID 比较
    return Id.Equals(other.Id);
}
```

## 实体设计最佳实践

### 1. 使用私有 Setter

实体的状态修改应该通过领域方法进行，而不是直接设置属性：

```csharp
public class Product : Entity<int>
{
    // ✅ 正确：私有 setter
    public string Name { get; private set; }
    public decimal Price { get; private set; }

    // ✅ 正确：通过领域方法修改状态
    public void ChangePrice(decimal newPrice)
    {
        if (newPrice <= 0)
            throw new DomainException("价格必须大于零");

        Price = newPrice;
        RaiseDomainEvent(new ProductPriceChangedEvent(Id, newPrice));
    }
}

// ❌ 错误：公共 setter 破坏了封装
public class Product : Entity<int>
{
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

### 2. 提供工厂方法

使用工厂方法创建实体，确保实体始终处于有效状态：

```csharp
public class User : Entity<int>
{
    public string UserName { get; private set; }
    public string Email { get; private set; }

    // 私有构造函数
    private User() { }

    // 工厂方法
    public static User Create(string userName, string email)
    {
        // 验证逻辑
        if (string.IsNullOrWhiteSpace(userName))
            throw new DomainException("用户名不能为空");

        if (string.IsNullOrWhiteSpace(email))
            throw new DomainException("邮箱不能为空");

        return new User
        {
            UserName = userName,
            Email = email
        };
    }
}
```

### 3. 领域行为优于属性

实体应该包含领域行为，而不仅仅是数据容器：

```csharp
public class BankAccount : Entity<int>
{
    public decimal Balance { get; private set; }
    
    // ✅ 正确：领域行为
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
            throw new DomainException("存款金额必须大于零");

        Balance += amount;
        RaiseDomainEvent(new MoneyDepositedEvent(Id, amount));
    }

    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
            throw new DomainException("取款金额必须大于零");

        if (Balance < amount)
            throw new DomainException("余额不足");

        Balance -= amount;
        RaiseDomainEvent(new MoneyWithdrawnEvent(Id, amount));
    }
}

// ❌ 错误：贫血模型
public class BankAccount : Entity<int>
{
    public decimal Balance { get; set; }
}

// 业务逻辑放在服务层（不推荐）
public class BankAccountService
{
    public void Deposit(BankAccount account, decimal amount)
    {
        account.Balance += amount; // 破坏封装
    }
}
```

### 4. 触发领域事件

在重要的状态变更时触发领域事件：

```csharp
public class Order : Entity<int>
{
    public OrderStatus Status { get; private set; }

    public void Confirm()
    {
        Status = OrderStatus.Confirmed;
        RaiseDomainEvent(new OrderConfirmedEvent(Id));
    }

    public void Cancel(string reason)
    {
        Status = OrderStatus.Cancelled;
        RaiseDomainEvent(new OrderCancelledEvent(Id, reason));
    }
}
```

## 与聚合根的区别

实体和聚合根的主要区别：

| 特性 | 实体 | 聚合根 |
|------|------|--------|
| 标识 | ✅ 有 | ✅ 有 |
| 可独立存在 | ❌ 否 | ✅ 是 |
| 仓储访问 | ❌ 否 | ✅ 是 |
| 事务边界 | ❌ 否 | ✅ 是 |

```csharp
// 聚合根
public class Order : AggregateRoot<int>
{
    private List<OrderItem> _items = new();
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
}

// 聚合内的实体
public class OrderItem : Entity<int>
{
    public int ProductId { get; private set; }
    public int Quantity { get; private set; }
    public decimal Price { get; private set; }
}

// ✅ 正确：通过聚合根访问
var order = await _orderRepository.FindAsync(orderId);
var items = order.Items;

// ❌ 错误：不应该有 OrderItem 的仓储
// var item = await _orderItemRepository.FindAsync(itemId);
```

## 实体生命周期

```csharp
// 1. 创建
var user = User.Create("Alice", "alice@example.com");

// 2. 修改
user.ChangeEmail("newemail@example.com");
user.UpdateProfile("Alice Smith", "Bio info");

// 3. 持久化（如果是聚合根）
await _userRepository.AddAsync(user);
await _userRepository.SaveChangesAsync(); // 领域事件在此时分发

// 4. 查询
var existingUser = await _userRepository.FindAsync(userId);

// 5. 更新
existingUser.ChangeEmail("another@example.com");
await _userRepository.SaveChangesAsync();

// 6. 删除
await _userRepository.DeleteAsync(user);
await _userRepository.SaveChangesAsync();
```

## 注意事项

1. **不要在实体构造函数中执行复杂逻辑**：ORM 需要无参构造函数
2. **ID 不可变**：使用 `init` 访问器保证 ID 不可修改
3. **默认 ID 实体不相等**：未持久化的实体（ID 为默认值）即使类型相同也不相等
4. **领域事件自动分发**：在 `SaveChangesAsync()` 时自动处理

## 下一步

- 了解[值对象](./值对象.md)
- 学习[聚合根](./聚合根.md)
- 探索[领域事件](./领域事件.md)
- 使用[仓储](./仓储.md)持久化实体
