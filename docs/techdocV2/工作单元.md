# 工作单元（Unit of Work）

工作单元（Unit of Work，UoW）模式维护一个受业务事务影响的对象列表，并协调这些变更的持久化和并发问题的处理。在 MiCake 中，工作单元自动管理事务边界。

## 什么是工作单元？

工作单元模式跟踪在业务事务期间所做的所有更改，并在完成时将所有更改作为一个单元提交到数据库。这确保了数据的一致性。

**核心特点：**
- 自动管理事务边界
- 确保数据一致性
- 协调多个仓储操作
- 成功时自动提交，失败时自动回滚

## 使用工作单元

### 使用 UnitOfWork 特性

MiCake 提供了 `[UnitOfWork]` 特性来声明事务边界：

```csharp
using MiCake.AspNetCore.Uow;

[ApiController]
[Route("api/[controller]")]
public class OrderController : ControllerBase
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Product, int> _productRepository;

    [HttpPost]
    [UnitOfWork] // 自动开启工作单元
    public async Task<IActionResult> CreateOrder([FromBody] CreateOrderDto dto)
    {
        // 1. 创建订单
        var order = Order.Create(dto.CustomerId, dto.ShippingAddress);
        
        foreach (var item in dto.Items)
        {
            order.AddItem(item.ProductId, item.ProductName, item.Price, item.Quantity);
        }
        
        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync();

        // 2. 更新产品库存
        foreach (var item in dto.Items)
        {
            var product = await _productRepository.FindAsync(item.ProductId);
            product.DecreaseStock(item.Quantity);
        }
        
        await _productRepository.SaveChangesAsync();

        // 方法正常返回时，自动提交事务
        // 如果抛出异常，自动回滚事务
        return Ok(order.Id);
    }
}
```

### 工作单元的执行流程

```
1. 请求进入控制器方法（标记了 [UnitOfWork]）
2. 开启数据库事务
3. 执行方法体中的代码
   - 创建/修改/删除实体
   - 调用 SaveChangesAsync()
4. 如果方法成功完成：
   - 提交事务
   - 分发领域事件
5. 如果方法抛出异常：
   - 回滚事务
   - 异常向上传播
```

## 工作单元配置

### 禁用自动提交

```csharp
[UnitOfWork(IsDisabled = true)] // 禁用工作单元
public async Task<IActionResult> GetOrder(int id)
{
    var order = await _orderRepository.FindAsync(id);
    return Ok(order);
}
```

### 在应用服务中使用

```csharp
public class OrderApplicationService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IRepository<Product, int> _productRepository;

    [UnitOfWork]
    public async Task<int> CreateOrderWithStock(CreateOrderCommand command)
    {
        // 所有操作在同一个事务中
        var order = Order.Create(command.CustomerId, command.ShippingAddress);
        
        foreach (var item in command.Items)
        {
            order.AddItem(item.ProductId, item.ProductName, item.Price, item.Quantity);
            
            var product = await _productRepository.FindAsync(item.ProductId);
            product.DecreaseStock(item.Quantity);
        }

        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync();
        await _productRepository.SaveChangesAsync();

        return order.Id;
    }
}
```

## 手动管理事务

在某些情况下，您可能需要手动管理事务：

```csharp
public class OrderService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IUnitOfWorkManager _uowManager;

    public async Task ProcessOrder(int orderId)
    {
        // 手动开始工作单元
        using (var uow = _uowManager.Begin())
        {
            try
            {
                var order = await _orderRepository.FindAsync(orderId);
                order.Process();
                
                await _orderRepository.SaveChangesAsync();

                // 手动提交
                await uow.CommitAsync();
            }
            catch
            {
                // 自动回滚（Dispose 时）
                throw;
            }
        }
    }
}
```

## 工作单元与领域事件

工作单元与领域事件紧密集成，确保事件在事务提交后才分发：

```csharp
[UnitOfWork]
public async Task ConfirmOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    
    // 触发领域事件
    order.Confirm(); // 内部调用 RaiseDomainEvent
    
    await _orderRepository.SaveChangesAsync();
    
    // 执行流程：
    // 1. 保存订单更改到数据库
    // 2. 提交事务
    // 3. 分发 OrderConfirmedEvent
    // 4. 事件处理器在独立的事务中执行
}
```

## 一个事务修改一个聚合根

根据 DDD 最佳实践，一个事务应该只修改一个聚合根：

```csharp
// ✅ 正确：一个事务修改一个聚合根
[UnitOfWork]
public async Task ConfirmOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    order.Confirm();
    await _orderRepository.SaveChangesAsync();
}

// ❌ 不推荐：一个事务修改多个聚合根
[UnitOfWork]
public async Task ConfirmOrderAndUpdateInventory(int orderId)
{
    // 应该使用领域事件来处理跨聚合的操作
    var order = await _orderRepository.FindAsync(orderId);
    order.Confirm();
    await _orderRepository.SaveChangesAsync();

    var product = await _productRepository.FindAsync(productId);
    product.DecreaseStock(quantity);
    await _productRepository.SaveChangesAsync();
}
```

### 使用领域事件处理跨聚合操作

```csharp
// 订单聚合根
[UnitOfWork]
public async Task ConfirmOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    
    // 触发事件，由事件处理器更新库存
    order.Confirm();
    
    await _orderRepository.SaveChangesAsync();
}

// 事件处理器（在独立的事务中执行）
public class OrderConfirmedEventHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    private readonly IRepository<Product, int> _productRepository;

    [UnitOfWork]
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 独立的事务
        foreach (var item in domainEvent.Items)
        {
            var product = await _productRepository.FindAsync(item.ProductId, cancellationToken);
            product.DecreaseStock(item.Quantity);
        }
        
        await _productRepository.SaveChangesAsync(cancellationToken);
    }
}
```

## 工作单元最佳实践

### 1. 方法级别使用

将 `[UnitOfWork]` 应用在方法级别，而不是类级别：

```csharp
// ✅ 正确：方法级别
public class OrderController : ControllerBase
{
    [HttpPost]
    [UnitOfWork]
    public async Task<IActionResult> CreateOrder([FromBody] CreateOrderDto dto)
    {
        // ...
    }

    [HttpGet("{id}")]
    // 查询操作不需要 UnitOfWork
    public async Task<IActionResult> GetOrder(int id)
    {
        // ...
    }
}

// ❌ 不推荐：类级别（所有方法都会开启事务）
[UnitOfWork]
public class OrderController : ControllerBase
{
    // ...
}
```

### 2. 查询操作不使用工作单元

只读查询不需要工作单元：

```csharp
// ✅ 正确：查询不使用 UnitOfWork
public async Task<OrderDto> GetOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    return MapToDto(order);
}

// ❌ 不必要：查询使用 UnitOfWork
[UnitOfWork]
public async Task<OrderDto> GetOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    return MapToDto(order);
}
```

### 3. 避免长时间事务

事务应该尽可能短：

```csharp
// ❌ 错误：事务时间过长
[UnitOfWork]
public async Task ProcessOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    
    // 外部 API 调用（可能很慢）
    await _externalPaymentService.ChargeCustomer(order);
    
    // 发送邮件（可能很慢）
    await _emailService.SendConfirmation(order);
    
    order.Confirm();
    await _orderRepository.SaveChangesAsync();
}

// ✅ 正确：只在必要时使用事务
public async Task ProcessOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    
    // 先完成外部操作
    await _externalPaymentService.ChargeCustomer(order);
    await _emailService.SendConfirmation(order);
    
    // 然后在短事务中更新数据库
    await UpdateOrder(orderId);
}

[UnitOfWork]
private async Task UpdateOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    order.Confirm();
    await _orderRepository.SaveChangesAsync();
}
```

### 4. 处理事务失败

正确处理事务失败的情况：

```csharp
[UnitOfWork]
public async Task<Result> CreateOrder(CreateOrderDto dto)
{
    try
    {
        var order = Order.Create(dto.CustomerId, dto.ShippingAddress);
        
        foreach (var item in dto.Items)
        {
            var product = await _productRepository.FindAsync(item.ProductId);
            if (product.Stock < item.Quantity)
            {
                return Result.Failure("库存不足");
            }
            
            order.AddItem(item.ProductId, item.ProductName, item.Price, item.Quantity);
            product.DecreaseStock(item.Quantity);
        }

        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync();
        await _productRepository.SaveChangesAsync();

        return Result.Success(order.Id);
    }
    catch (DbUpdateConcurrencyException)
    {
        return Result.Failure("数据已被修改，请刷新后重试");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "创建订单失败");
        return Result.Failure("创建订单失败");
    }
}
```

## SaveChangesAsync 的作用

在工作单元中，`SaveChangesAsync` 执行以下操作：

```csharp
[UnitOfWork]
public async Task ProcessOrder(int orderId)
{
    var order = await _orderRepository.FindAsync(orderId);
    order.Process();
    
    // SaveChangesAsync 执行：
    // 1. 收集所有待持久化的更改
    // 2. 收集所有领域事件
    // 3. 执行数据库操作
    // 4. 如果成功：
    //    - 工作单元提交事务
    //    - 分发领域事件
    //    - 清除更改跟踪
    // 5. 如果失败：
    //    - 抛出异常
    //    - 工作单元回滚事务
    await _orderRepository.SaveChangesAsync();
}
```

## 嵌套工作单元

MiCake 支持嵌套的工作单元：

```csharp
[UnitOfWork]
public async Task OuterMethod()
{
    // 外层工作单元
    
    await InnerMethod();
    
    // 外层工作单元提交时，内层的更改也会一起提交
}

[UnitOfWork]
private async Task InnerMethod()
{
    // 内层工作单元
    // 使用与外层相同的事务
}
```

## 工作单元与 DbContext

在使用 Entity Framework Core 时，工作单元实际上管理着 DbContext 的生命周期：

```csharp
public class MyDbContext : MiCakeDbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        // 配置实体映射
    }
}

// UnitOfWork 确保：
// 1. DbContext 在方法开始时创建
// 2. 所有仓储共享同一个 DbContext 实例
// 3. 在方法结束时正确提交或回滚
// 4. DbContext 被正确释放
```

## 注意事项

1. **只用于写操作**：查询操作不需要工作单元
2. **保持事务短小**：避免在事务中执行耗时操作
3. **一个事务一个聚合根**：遵循 DDD 最佳实践
4. **自动回滚**：异常会自动触发回滚
5. **领域事件在提交后分发**：确保数据一致性

## 下一步

- 了解[聚合根](./聚合根.md)的事务边界
- 学习[领域事件](./领域事件.md)的分发机制
- 探索[仓储](./仓储.md)的使用
