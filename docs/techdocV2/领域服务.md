# 领域服务（Domain Service）

领域服务用于实现不适合放在单个实体或值对象中的领域逻辑，特别是涉及多个聚合根的业务规则。

## 什么是领域服务？

领域服务是无状态的服务，用于封装领域逻辑。当某个业务操作：

- 涉及多个聚合根
- 不自然地属于任何一个实体或值对象
- 需要访问外部资源或基础设施

就应该使用领域服务。

**领域服务 vs 应用服务：**

| 特性 | 领域服务 | 应用服务 |
|------|----------|----------|
| 位置 | 领域层 | 应用层 |
| 职责 | 核心业务逻辑 | 编排和协调 |
| 依赖 | 领域对象、其他领域服务 | 领域服务、仓储、基础设施 |
| 事务 | 不管理事务 | 管理事务边界 |

## 定义领域服务

实现 `IDomainService` 接口标记为领域服务：

```csharp
using MiCake.DDD.Domain;

public interface IOrderPricingService : IDomainService
{
    decimal CalculateTotal(Order order);
    decimal ApplyDiscount(Order order, Coupon coupon);
    Money CalculateShippingCost(Order order, Address address);
}

public class OrderPricingService : IOrderPricingService
{
    public decimal CalculateTotal(Order order)
    {
        decimal subtotal = 0;
        
        foreach (var item in order.Items)
        {
            subtotal += item.Price * item.Quantity;
        }

        return subtotal;
    }

    public decimal ApplyDiscount(Order order, Coupon coupon)
    {
        var total = CalculateTotal(order);

        if (!coupon.IsValid())
            return total;

        if (coupon.Type == CouponType.Percentage)
        {
            return total * (1 - coupon.Value / 100);
        }
        else if (coupon.Type == CouponType.Fixed)
        {
            return Math.Max(0, total - coupon.Value);
        }

        return total;
    }

    public Money CalculateShippingCost(Order order, Address address)
    {
        // 复杂的运费计算逻辑
        var weight = order.GetTotalWeight();
        var distance = CalculateDistance(order.WarehouseLocation, address);
        
        decimal cost = weight * 0.5m + distance * 0.1m;
        return new Money(cost, "CNY");
    }

    private decimal CalculateDistance(Location from, Address to)
    {
        // 距离计算逻辑
        return 100m;
    }
}
```

## 使用场景

### 1. 跨多个聚合的业务规则

当业务规则涉及多个聚合根时，使用领域服务：

```csharp
public interface ITransferService : IDomainService
{
    Task<TransferResult> TransferMoney(
        BankAccount fromAccount, 
        BankAccount toAccount, 
        Money amount);
}

public class TransferService : ITransferService
{
    public async Task<TransferResult> TransferMoney(
        BankAccount fromAccount,
        BankAccount toAccount,
        Money amount)
    {
        // 验证转账规则
        if (fromAccount.Currency != toAccount.Currency)
            throw new DomainException("不能在不同货币的账户间转账");

        if (fromAccount.Balance < amount)
            throw new DomainException("余额不足");

        // 执行转账
        fromAccount.Withdraw(amount);
        toAccount.Deposit(amount);

        return new TransferResult
        {
            TransactionId = Guid.NewGuid(),
            FromBalance = fromAccount.Balance,
            ToBalance = toAccount.Balance
        };
    }
}
```

### 2. 复杂的计算逻辑

将复杂的计算逻辑封装在领域服务中：

```csharp
public interface IShippingCostCalculator : IDomainService
{
    Money Calculate(Order order, ShippingMethod method, Address destination);
}

public class ShippingCostCalculator : IShippingCostCalculator
{
    public Money Calculate(Order order, ShippingMethod method, Address destination)
    {
        // 1. 计算重量
        var weight = order.Items.Sum(item => item.Weight * item.Quantity);

        // 2. 计算距离
        var distance = CalculateDistance(order.WarehouseLocation, destination);

        // 3. 根据运输方式计算费用
        decimal baseCost = method.Type switch
        {
            ShippingType.Standard => weight * 5 + distance * 0.1m,
            ShippingType.Express => weight * 10 + distance * 0.2m,
            ShippingType.Overnight => weight * 20 + distance * 0.5m,
            _ => throw new ArgumentException("Unknown shipping type")
        };

        // 4. 应用重量折扣
        if (weight > 10)
        {
            baseCost *= 0.9m; // 10kg 以上 9 折
        }

        // 5. 应用距离折扣
        if (distance > 1000)
        {
            baseCost *= 0.95m; // 1000km 以上 95 折
        }

        return new Money(baseCost, "CNY");
    }

    private decimal CalculateDistance(Location from, Address to)
    {
        // 使用地理位置计算距离
        return 500m;
    }
}
```

### 3. 业务规则验证

封装复杂的业务规则验证：

```csharp
public interface IOrderValidator : IDomainService
{
    ValidationResult Validate(Order order);
    bool CanConfirm(Order order);
    bool CanCancel(Order order);
}

public class OrderValidator : IOrderValidator
{
    public ValidationResult Validate(Order order)
    {
        var result = new ValidationResult();

        // 1. 验证订单项
        if (!order.Items.Any())
        {
            result.AddError("订单至少需要一个商品");
        }

        // 2. 验证金额
        if (order.TotalAmount <= 0)
        {
            result.AddError("订单金额必须大于零");
        }

        // 3. 验证收货地址
        if (order.ShippingAddress == null)
        {
            result.AddError("必须提供收货地址");
        }

        // 4. 验证库存
        foreach (var item in order.Items)
        {
            if (item.Quantity > item.Product.Stock)
            {
                result.AddError($"商品 {item.ProductName} 库存不足");
            }
        }

        return result;
    }

    public bool CanConfirm(Order order)
    {
        return order.Status == OrderStatus.Draft && 
               Validate(order).IsValid;
    }

    public bool CanCancel(Order order)
    {
        return order.Status != OrderStatus.Shipped && 
               order.Status != OrderStatus.Completed;
    }
}
```

### 4. 与外部系统的交互

当需要与外部系统交互并包含业务规则时，使用领域服务：

```csharp
public interface IPaymentService : IDomainService
{
    Task<PaymentResult> ProcessPayment(Order order, PaymentMethod method);
    Task<RefundResult> RefundPayment(Payment payment, Money amount);
}

public class PaymentService : IPaymentService
{
    private readonly IPaymentGateway _paymentGateway;

    public PaymentService(IPaymentGateway paymentGateway)
    {
        _paymentGateway = paymentGateway;
    }

    public async Task<PaymentResult> ProcessPayment(Order order, PaymentMethod method)
    {
        // 业务规则验证
        if (order.Status != OrderStatus.Confirmed)
            throw new DomainException("只能为已确认的订单支付");

        if (order.TotalAmount <= 0)
            throw new DomainException("支付金额必须大于零");

        // 调用外部支付网关
        var gatewayResult = await _paymentGateway.Charge(
            amount: order.TotalAmount,
            currency: "CNY",
            method: method,
            orderId: order.Id.ToString()
        );

        if (!gatewayResult.Success)
        {
            return PaymentResult.Failed(gatewayResult.ErrorMessage);
        }

        return PaymentResult.Success(gatewayResult.TransactionId, order.TotalAmount);
    }

    public async Task<RefundResult> RefundPayment(Payment payment, Money amount)
    {
        // 业务规则验证
        if (payment.Status != PaymentStatus.Completed)
            throw new DomainException("只能退款已完成的支付");

        if (amount > payment.Amount)
            throw new DomainException("退款金额不能超过支付金额");

        // 调用外部支付网关
        var gatewayResult = await _paymentGateway.Refund(
            transactionId: payment.TransactionId,
            amount: amount.Amount
        );

        if (!gatewayResult.Success)
        {
            return RefundResult.Failed(gatewayResult.ErrorMessage);
        }

        return RefundResult.Success(gatewayResult.RefundId, amount);
    }
}
```

## 在聚合根中使用领域服务

领域服务可以作为参数传递给聚合根的方法：

```csharp
public class Order : AggregateRoot<int>
{
    public decimal TotalAmount { get; private set; }
    public decimal ShippingCost { get; private set; }

    // 方式 1：通过方法参数注入领域服务
    public void CalculateTotal(IOrderPricingService pricingService)
    {
        TotalAmount = pricingService.CalculateTotal(this);
    }

    public void ApplyShippingCost(
        IShippingCostCalculator calculator, 
        ShippingMethod method, 
        Address destination)
    {
        var cost = calculator.Calculate(this, method, destination);
        ShippingCost = cost.Amount;
        TotalAmount += ShippingCost;
    }

    // 方式 2：通过工厂方法注入领域服务
    public static Order CreateWithPricing(
        int customerId,
        Address shippingAddress,
        List<OrderItemDto> items,
        IOrderPricingService pricingService)
    {
        var order = new Order
        {
            CustomerId = customerId,
            ShippingAddress = shippingAddress
        };

        foreach (var item in items)
        {
            order.AddItem(item.ProductId, item.ProductName, item.Price, item.Quantity);
        }

        // 使用领域服务计算总金额
        order.TotalAmount = pricingService.CalculateTotal(order);

        return order;
    }
}
```

## 在应用服务中使用领域服务

应用服务编排领域服务和仓储：

```csharp
public class OrderApplicationService
{
    private readonly IRepository<Order, int> _orderRepository;
    private readonly IOrderPricingService _pricingService;
    private readonly IShippingCostCalculator _shippingCalculator;
    private readonly IOrderValidator _orderValidator;

    public OrderApplicationService(
        IRepository<Order, int> orderRepository,
        IOrderPricingService pricingService,
        IShippingCostCalculator shippingCalculator,
        IOrderValidator orderValidator)
    {
        _orderRepository = orderRepository;
        _pricingService = pricingService;
        _shippingCalculator = shippingCalculator;
        _orderValidator = orderValidator;
    }

    [UnitOfWork]
    public async Task<int> CreateOrder(CreateOrderCommand command)
    {
        // 1. 创建订单
        var order = Order.Create(command.CustomerId, command.ShippingAddress);

        // 2. 添加订单项
        foreach (var item in command.Items)
        {
            order.AddItem(item.ProductId, item.ProductName, item.Price, item.Quantity);
        }

        // 3. 使用领域服务计算价格
        order.CalculateTotal(_pricingService);

        // 4. 使用领域服务计算运费
        order.ApplyShippingCost(
            _shippingCalculator,
            command.ShippingMethod,
            command.ShippingAddress
        );

        // 5. 使用领域服务验证
        var validation = _orderValidator.Validate(order);
        if (!validation.IsValid)
        {
            throw new ValidationException(validation.Errors);
        }

        // 6. 持久化
        await _orderRepository.AddAsync(order);
        await _orderRepository.SaveChangesAsync();

        return order.Id;
    }
}
```

## 领域服务设计最佳实践

### 1. 保持无状态

领域服务应该是无状态的：

```csharp
// ✅ 正确：无状态
public class OrderPricingService : IOrderPricingService
{
    public decimal CalculateTotal(Order order)
    {
        // 不存储任何状态
        return order.Items.Sum(item => item.Price * item.Quantity);
    }
}

// ❌ 错误：有状态
public class OrderPricingService : IOrderPricingService
{
    private Order _currentOrder; // 不应该存储状态

    public void SetOrder(Order order)
    {
        _currentOrder = order;
    }

    public decimal CalculateTotal()
    {
        return _currentOrder.Items.Sum(item => item.Price * item.Quantity);
    }
}
```

### 2. 使用接口定义

总是为领域服务定义接口：

```csharp
// ✅ 正确：使用接口
public interface IPaymentService : IDomainService
{
    Task<PaymentResult> ProcessPayment(Order order, PaymentMethod method);
}

public class PaymentService : IPaymentService
{
    // 实现
}

// ❌ 错误：直接使用实现类
public class PaymentService : IDomainService
{
    // 无接口
}
```

### 3. 明确参数

领域服务的方法应该明确接受它需要的所有参数：

```csharp
// ✅ 正确：明确的参数
public interface IDiscountCalculator : IDomainService
{
    decimal Calculate(decimal originalPrice, Coupon coupon, CustomerLevel level);
}

// ❌ 错误：隐式依赖
public interface IDiscountCalculator : IDomainService
{
    decimal Calculate(); // 从哪里获取数据？
}
```

### 4. 单一职责

每个领域服务应该有单一的职责：

```csharp
// ✅ 正确：单一职责
public interface IOrderPricingService : IDomainService
{
    decimal CalculateTotal(Order order);
}

public interface IShippingCostCalculator : IDomainService
{
    Money Calculate(Order order, ShippingMethod method);
}

// ❌ 错误：职责过多
public interface IOrderService : IDomainService
{
    decimal CalculateTotal(Order order);
    Money CalculateShipping(Order order);
    bool ValidateOrder(Order order);
    void SendNotification(Order order);
    // ... 太多职责
}
```

## 领域服务 vs 应用服务

```csharp
// 领域服务 - 纯业务逻辑
public class TransferService : ITransferService
{
    public TransferResult Transfer(BankAccount from, BankAccount to, Money amount)
    {
        // 只包含业务规则
        if (from.Balance < amount)
            throw new DomainException("余额不足");

        from.Withdraw(amount);
        to.Deposit(amount);

        return new TransferResult { Success = true };
    }
}

// 应用服务 - 编排和协调
public class BankAccountApplicationService
{
    private readonly IRepository<BankAccount, int> _accountRepository;
    private readonly ITransferService _transferService;

    [UnitOfWork]
    public async Task<TransferResult> Transfer(int fromAccountId, int toAccountId, Money amount)
    {
        // 1. 获取聚合根
        var fromAccount = await _accountRepository.FindAsync(fromAccountId);
        var toAccount = await _accountRepository.FindAsync(toAccountId);

        // 2. 调用领域服务
        var result = _transferService.Transfer(fromAccount, toAccount, amount);

        // 3. 持久化
        await _accountRepository.SaveChangesAsync();

        // 4. 返回结果
        return result;
    }
}
```

## 自动注册

实现 `IDomainService` 的类会自动注册为作用域（Scoped）服务：

```csharp
public interface IMyDomainService : IDomainService
{
    // ...
}

public class MyDomainService : IMyDomainService
{
    // 自动注册为 Scoped 生命周期
}
```

## 注意事项

1. **保持无状态**：领域服务不应该存储状态
2. **不管理事务**：事务由应用服务或仓储管理
3. **包含纯业务逻辑**：不包含技术细节
4. **通过接口定义**：便于测试和替换
5. **谨慎使用**：不要过度使用领域服务，优先考虑将逻辑放在实体中

## 下一步

- 了解[工作单元](./工作单元.md)管理事务
- 学习[聚合根](./聚合根.md)的职责划分
- 探索[仓储](./仓储.md)的使用
