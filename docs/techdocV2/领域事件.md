# 领域事件（Domain Event）

领域事件是领域中发生的重要业务活动的记录。它们用于解耦领域逻辑，实现不同聚合之间的通信和最终一致性。

## 什么是领域事件？

领域事件表示领域中已经发生的事情。它是一种轻量级的、域内的通知机制，用于在聚合根之间传递信息而不直接耦合它们。

**常见的领域事件：**
- `OrderCreatedEvent` - 订单已创建
- `PaymentCompletedEvent` - 支付已完成
- `ProductStockChangedEvent` - 产品库存已变更
- `UserEmailChangedEvent` - 用户邮箱已更改

**核心特点：**
- 表示已经发生的事情（过去式命名）
- 不可变（immutable）
- 在 `SaveChangesAsync` 时自动分发
- 支持多个处理器

## 定义领域事件

### 基本定义

继承 `DomainEvent` 基类：

```csharp
using MiCake.DDD.Domain;

public class OrderCreatedEvent : DomainEvent
{
    public int OrderId { get; }
    public int CustomerId { get; }
    public decimal TotalAmount { get; }
    public DateTime CreatedAt { get; }

    public OrderCreatedEvent(int orderId, int customerId, decimal totalAmount)
    {
        OrderId = orderId;
        CustomerId = customerId;
        TotalAmount = totalAmount;
        CreatedAt = DateTime.UtcNow;
    }
}
```

### 事件命名规范

领域事件应该使用过去式命名，表示已经发生的事情：

```csharp
// ✅ 正确：过去式
public class OrderConfirmedEvent : DomainEvent { }
public class PaymentProcessedEvent : DomainEvent { }
public class EmailSentEvent : DomainEvent { }

// ❌ 错误：现在式或祈使式
public class ConfirmOrderEvent : DomainEvent { }
public class ProcessPaymentEvent : DomainEvent { }
public class SendEmailEvent : DomainEvent { }
```

### 事件的不可变性

领域事件应该是不可变的，只有 `init` 或只读属性：

```csharp
public class ProductPriceChangedEvent : DomainEvent
{
    public int ProductId { get; init; }
    public decimal OldPrice { get; init; }
    public decimal NewPrice { get; init; }
    public DateTime ChangedAt { get; init; }

    public ProductPriceChangedEvent(int productId, decimal oldPrice, decimal newPrice)
    {
        ProductId = productId;
        OldPrice = oldPrice;
        NewPrice = newPrice;
        ChangedAt = DateTime.UtcNow;
    }
}
```

## 触发领域事件

在聚合根中使用 `RaiseDomainEvent` 方法触发领域事件：

```csharp
public class Order : AggregateRoot<int>
{
    public OrderStatus Status { get; private set; }
    public decimal TotalAmount { get; private set; }

    public static Order Create(int customerId, Address shippingAddress)
    {
        var order = new Order
        {
            CustomerId = customerId,
            ShippingAddress = shippingAddress,
            Status = OrderStatus.Draft
        };

        // 触发领域事件
        order.RaiseDomainEvent(new OrderCreatedEvent(order.Id, customerId, 0));
        
        return order;
    }

    public void Confirm()
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException("只能确认草稿状态的订单");

        Status = OrderStatus.Confirmed;
        
        // 触发领域事件
        RaiseDomainEvent(new OrderConfirmedEvent(Id, TotalAmount));
    }

    public void Cancel(string reason)
    {
        if (Status == OrderStatus.Shipped)
            throw new DomainException("已发货的订单不能取消");

        Status = OrderStatus.Cancelled;
        
        // 触发领域事件
        RaiseDomainEvent(new OrderCancelledEvent(Id, reason, DateTime.UtcNow));
    }
}
```

## 处理领域事件

### 定义事件处理器

实现 `IDomainEventHandler<TDomainEvent>` 接口：

```csharp
using MiCake.DDD.Domain;
using System.Threading;
using System.Threading.Tasks;

public class OrderConfirmedEventHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    private readonly IRepository<Product, int> _productRepository;
    private readonly IEmailService _emailService;

    public OrderConfirmedEventHandler(
        IRepository<Product, int> productRepository,
        IEmailService emailService)
    {
        _productRepository = productRepository;
        _emailService = emailService;
    }

    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 1. 更新库存
        foreach (var item in domainEvent.Items)
        {
            var product = await _productRepository.FindAsync(item.ProductId, cancellationToken);
            if (product != null)
            {
                product.DecreaseStock(item.Quantity);
            }
        }
        await _productRepository.SaveChangesAsync(cancellationToken);

        // 2. 发送确认邮件
        await _emailService.SendOrderConfirmationEmail(
            domainEvent.OrderId, 
            domainEvent.CustomerEmail,
            cancellationToken);
    }
}
```

### 多个处理器

一个事件可以有多个处理器，它们会按注册顺序执行：

```csharp
// 处理器 1：更新库存
public class OrderConfirmedStockHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 更新库存逻辑
    }
}

// 处理器 2：发送通知
public class OrderConfirmedNotificationHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 发送通知逻辑
    }
}

// 处理器 3：记录日志
public class OrderConfirmedLoggingHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 记录日志逻辑
    }
}
```

## 事件分发机制

领域事件在 `SaveChangesAsync` 时自动分发：

```csharp
public async Task ConfirmOrder(int orderId)
{
    // 1. 加载聚合根
    var order = await _orderRepository.FindAsync(orderId);
    
    // 2. 执行领域操作（触发事件）
    order.Confirm(); // 内部调用 RaiseDomainEvent(new OrderConfirmedEvent(...))
    
    // 3. 保存更改（自动分发事件）
    await _orderRepository.SaveChangesAsync();
    
    // 执行流程：
    // 3.1 收集所有领域事件
    // 3.2 保存数据库更改
    // 3.3 依次分发事件给所有处理器
    // 3.4 清除领域事件
}
```

**分发流程图：**

```
聚合根.Method()
    ↓
RaiseDomainEvent(event)
    ↓
事件存储在聚合根的 DomainEvents 集合中
    ↓
SaveChangesAsync()
    ↓
收集所有领域事件
    ↓
保存到数据库
    ↓
分发事件给处理器（按顺序）
    ↓
清除领域事件
```

## 使用场景

### 1. 跨聚合的业务逻辑

当需要在多个聚合之间执行业务逻辑时，使用领域事件解耦：

```csharp
// 订单聚合根
public class Order : AggregateRoot<int>
{
    public void Confirm()
    {
        Status = OrderStatus.Confirmed;
        
        // 不直接调用产品聚合根，而是触发事件
        RaiseDomainEvent(new OrderConfirmedEvent(Id, GetOrderItems()));
    }
}

// 事件处理器：更新产品库存
public class OrderConfirmedHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    private readonly IRepository<Product, int> _productRepository;

    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 在独立的事务中更新另一个聚合根
        foreach (var item in domainEvent.Items)
        {
            var product = await _productRepository.FindAsync(item.ProductId, cancellationToken);
            product.DecreaseStock(item.Quantity);
        }
        
        await _productRepository.SaveChangesAsync(cancellationToken);
    }
}
```

### 2. 解耦副作用

将领域操作的副作用（如发送邮件、记录日志）解耦到事件处理器中：

```csharp
public class User : AggregateRoot<int>
{
    public string Email { get; private set; }

    public void ChangeEmail(string newEmail)
    {
        var oldEmail = Email;
        Email = newEmail;
        
        // 触发事件，由处理器负责发送确认邮件
        RaiseDomainEvent(new UserEmailChangedEvent(Id, oldEmail, newEmail));
    }
}

// 事件处理器：发送邮件
public class UserEmailChangedHandler : IDomainEventHandler<UserEmailChangedEvent>
{
    private readonly IEmailService _emailService;

    public async Task HandleAsync(UserEmailChangedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 发送确认邮件
        await _emailService.SendEmailChangeConfirmation(
            domainEvent.UserId,
            domainEvent.OldEmail,
            domainEvent.NewEmail,
            cancellationToken);
    }
}
```

### 3. 审计和日志

使用事件记录重要的业务操作：

```csharp
public class Product : AggregateRoot<int>
{
    public decimal Price { get; private set; }

    public void ChangePrice(decimal newPrice)
    {
        var oldPrice = Price;
        Price = newPrice;
        
        // 触发事件，用于审计
        RaiseDomainEvent(new ProductPriceChangedEvent(Id, oldPrice, newPrice));
    }
}

// 事件处理器：记录审计日志
public class ProductPriceChangedHandler : IDomainEventHandler<ProductPriceChangedEvent>
{
    private readonly IAuditLogService _auditLogService;

    public async Task HandleAsync(ProductPriceChangedEvent domainEvent, CancellationToken cancellationToken)
    {
        await _auditLogService.LogPriceChange(
            domainEvent.ProductId,
            domainEvent.OldPrice,
            domainEvent.NewPrice,
            cancellationToken);
    }
}
```

### 4. 实现最终一致性

通过事件在不同聚合之间实现最终一致性：

```csharp
// 订单确认事件
public class OrderConfirmedEvent : DomainEvent
{
    public int OrderId { get; }
    public int CustomerId { get; }
    public List<OrderItemDto> Items { get; }
}

// 处理器 1：更新产品库存
public class UpdateInventoryHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 更新库存聚合
    }
}

// 处理器 2：更新客户积分
public class UpdateCustomerPointsHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 更新客户积分聚合
    }
}
```

## 最佳实践

### 1. 事件应该描述已发生的事实

```csharp
// ✅ 正确：描述已发生的事实
public class OrderShippedEvent : DomainEvent
{
    public int OrderId { get; }
    public string TrackingNumber { get; }
    public DateTime ShippedAt { get; }
}

// ❌ 错误：包含命令式语义
public class ShipOrderEvent : DomainEvent
{
    public int OrderId { get; }
    public string TrackingNumber { get; }
}
```

### 2. 事件应包含足够的信息

```csharp
// ✅ 正确：包含足够的上下文信息
public class OrderCancelledEvent : DomainEvent
{
    public int OrderId { get; }
    public int CustomerId { get; }
    public string Reason { get; }
    public decimal RefundAmount { get; }
    public DateTime CancelledAt { get; }
}

// ❌ 错误：信息不足
public class OrderCancelledEvent : DomainEvent
{
    public int OrderId { get; }
}
```

### 3. 保持事件处理器简单

```csharp
// ✅ 正确：每个处理器只做一件事
public class SendOrderConfirmationEmailHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 只发送邮件
        await _emailService.SendConfirmationEmail(domainEvent);
    }
}

// ❌ 错误：处理器做太多事情
public class OrderConfirmedHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        // 更新库存
        // 发送邮件
        // 记录日志
        // 更新统计
        // 发送消息队列
        // ... 太多职责
    }
}
```

### 4. 处理事件失败

```csharp
public class OrderConfirmedHandler : IDomainEventHandler<OrderConfirmedEvent>
{
    private readonly ILogger<OrderConfirmedHandler> _logger;

    public async Task HandleAsync(OrderConfirmedEvent domainEvent, CancellationToken cancellationToken)
    {
        try
        {
            // 处理事件
            await ProcessEvent(domainEvent, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "处理订单确认事件失败: OrderId={OrderId}", domainEvent.OrderId);
            
            // 根据业务需求决定是否重新抛出异常
            // throw; // 会导致整个事务回滚
        }
    }
}
```

## 查看聚合根的事件

您可以查看聚合根当前的领域事件：

```csharp
var order = Order.Create(customerId, address);
order.AddItem(productId, productName, price, quantity);
order.Confirm();

// 查看待处理的领域事件
var events = order.DomainEvents;
foreach (var evt in events)
{
    Console.WriteLine($"Event: {evt.GetType().Name}");
}

// 手动清除事件（通常不需要，SaveChangesAsync 会自动清除）
order.ClearDomainEvents();
```

## 注意事项

1. **事件在 SaveChangesAsync 时分发**：不是在触发时立即执行
2. **事件处理器的执行顺序**：按注册顺序执行，但不应该依赖顺序
3. **事件处理失败**：默认会导致整个事务回滚
4. **跨聚合操作**：使用事件而不是直接引用
5. **事件应该是不可变的**：一旦创建就不应该修改

## 下一步

- 了解[领域服务](./领域服务.md)
- 学习[工作单元](./工作单元.md)管理事务
- 探索[聚合根](./聚合根.md)的事件触发机制
